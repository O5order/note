# 进阶Cday1



[TOC]



## 杂项

- ### 	使用typedef说明新类型名，再去定义变量指针或数组

####      	格式：typedef 类型名  标识符；

​					说明：将已存在的一种类型名说明成另一个名称，typedef 语句的作用仅仅是用标识符来代表已存在的型名,并未产生新的数据					类型,原有类型名依然有效。

​					需要解决的下一个问题是使用函数指针向其它函数提供参数比较困难，比如当你打算向其它函数传递回调函数的时候。解决方					法是使用typedef，它是C的一个关键字，可以给其它更复杂的类型起个新的名字。你需要记住的事情是，将typedef添加到					相同的指针语法之前，然后你就可以将那个名字用作类型了。

- ### 	`struct`占用内存为该成员中占用最大内存的字节数的整数倍

## 内存占用

- 程序没有加载到内存前，可执行程序内部已经分好3段信息，分别为代码区（text）、数据区（data）和未初始化数据区（`bss`）3 个部分（有些人直接把data`和``bss``合起来叫做静态区或全局区`）。

- 程序在加载到内存前，**代码区和全局区**(`data和`bss`)的大小就是固定的**，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外**增加了栈区、堆区。

- 全局静态区：全局区/静态区-

  - static int a;//内部链接，只能在当前文件，不可以在其他文件中引用

  - 作用域不同 extern int a;  //外部链接（函数和变量默认为外部链接）
    - extern //声明，表示告诉编译器这个符号是存在的，先编译通过，让链接器去找这个符号在哪，找不到报链接错误，函数声明也一样  如：`exturn int g_a;`，另一个文件：int g_a = 100;<!--由于默认为外部链接，所以extern声明的该变量要在此文件夹中唯一，不能含有多个-->

- **内存分布图：**
- ![image-20231116080051722](http://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20231116080051722.png)

- 常量区-`const`  常量区的数据一旦初始化，不能修改，只读，一直到程序结束才会消失。

  - `const`全局和局部变量的区别：

    **`const`全局变量在常量区，不能修改（直接或者间接）**

    `const`修饰局部变量，在栈上，不能直接修改，可间接，**因此只要在堆栈上的空间都可修改**

    

  - 字符串常量尽量不要去修改，同时不同编译器字符串常量地址不一定相同

    ------

    

- 栈区，堆区详解：

  - 大数据量在堆上 否则会出现栈溢出的问题,**堆使用后要进行及时释放，避免内存泄漏**

  - 栈变量生命周期短，很有可能引用时已经死亡

  - ![image-20231116081440813](http://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20231116081440813.png)如图，不要在栈区（局部变量)返回地址，**因为大括号结束后会被释放**，`str`在`getstring`执行结束后被释放，回传的地址原位置为未定义行为，**什么值都有可能出现**。

    ------

    

  - ![image-20231116084624448](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20231116084624448.png)如图，指针在函数间回传也不会导致源地址的改变，一个函数不回传那么**该函数中指针的赋值只会影响该函数中的形参指针，与原函数中实参指针无关**，||但是**数组特殊**，由于连续储存，数组在函数传递过程中**改变的是源地址值的存储**，因此数组尽管函数不回传，形参实参都会改变。||通常情况下**间接赋值**的方式是指针和回传地址的结合，因此**多级指针和一级指针**可以通过降*转化为**一级指针和常量的关系**，如下图即为一级指针通过二级指针的间接赋值![image-20231116091145964](http://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20231116091145964.png)

### 内存分区总结：

​		我们要想执行我们编写的c程序，那么第一步需要对这个程序进行编译。

​            1）     **预处理**：宏定义展开、头文件展开、条件编译，这里并不会检查语法            

​			2）     **编译**：检查语法，将预处理后文件编译生成汇编文件            

​			3）     **汇编**：将汇编文件生成目标文件(二进制文件)            

​			4）     **链接**：将目标文件链接为可执行程序

​	![image-20231116154004575](http://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20231116154004575.png)

## c语言进制转换

将原码的符号位不变，其他位依次按位取反就可以得到反码

反码+1就得到补码

PS：正数的原、反、补码都相同，整型数据存放内存中其实存放的补码

在计算机系统中，**数值一律用补码来表示和存储**

原因在于，使用补码，可以将符号和数值统一处理，加法和减法也可以统一处理（CPU只有加法器）

补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

### 十六进制和整型数据的存储

计算机中，二进制数可以转为十六进制数，一个十六进制数相当于4个2进制，也就是4个bit，**两个十六进制数为一个字节**

大端：数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中

小端：数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中

例子：

int a = 0x123;
//在内存中，int类型有4个字节，2个十六进制数为一个字节
//所以有8个十六进制进制数
//补齐0是  0x 00 00 01 23
//  数据高位-------------数据低位
//  内存中：
//   大端    00 00 01 23
//   小端    23 01 00 00
//  低地址-----------------高地址

浮点型存储参考：[【精选】内存中数据的存储（更新了十六进制数大小端存储）_16进制数在内存中的存放方式-CSDN博客](https://blog.csdn.net/qq_53656490/article/details/120335145))

## 注释

- 只要是连续的内存空间，都能使用下标的方式访问内存

-  -- ++i  效率高，而i-- ++多产生一个临时变量，效率低，但两个都可

-  //用完堆内存，一定要释放

    释放基本方式：

    `free(ret);`

    `ret = NULL；`

- **p 不知道p指向什么类型数据， `**p` 想知道指针指向空间指向什么类型，降*`*`,降一级即为它指向的数据类型