# 进阶Cday3

[TOC]

------



## calloc,realloc

`#include <stdlib.h>`  void *****calloc**(**size_t nmemb**,** size_t size**);**

在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存置0。参数：nmemb：所需内存单元数量size：每个内存单元的大小（单位：字节）

返回值：	成功：分配空间的起始地址

​					失败：NULL



#include <stdlib.h>void *****realloc**(**void *****ptr**,** size_t size**);**

重新分配用malloc或者calloc函数在堆中分配内存空间的大小。realloc不会自动清理增加的内存，需要手动清理.

如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存

参数：ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致

​			size：为重新分配内存的大小**,** 单位：字节

返回值：成功：新分配的堆内存地址

​				失败：NULL

## 自定义mystrstr字符串

```
//查找子串第一次出现的位置
char *mystrstr(const char *str, const char *substr)
{
	const char *mystr = str;  		//定义其他指针存地址，防止原地址字符串改变
	const char *mysubstr = substr;
	while(*mystr != '\0')			//主字符串未结束，则继续遍历
	{
		if(*mystr!=*mysubstr)
		{
			++mystr;
			continue;
		}							
	
		// 临时指针					//主子字符串出现第一个相同的字符
		const char *temp_mystr = mystr;
		const char *temp_mysubstr = mysubstr;
		while(*temp_mysubstr != '\0')
		{
			if(*temp_mystr != *temp_mysubstr)
			{
				++mystr;			//验证之后的主字符串和子字符串是否相同，不相同break继续遍历
				break;
			}
			++temp_mystr;
			++temp_mysubdtr;
		}
		if(temp_mysubstr == '\0')  //子字符串结束，说明匹配到相同字符串，返回此时的首地址
		{
			return mystr;
		}
	}
}
```

## 指针易错点

- 开辟空间指向的指针不能改变指向地址，否则free会崩溃，因为发生了溢出，free了未开辟的空间，因此一般使用时用一个新指针继承开辟空间的指针的储存地址。

- 注意每次free后，原指针NULL化，防止野指针及多次释放的问题。

## const进一步使用

​	多在结构体，字符串等传递的时候，在形参中添加，防止在函数里被意外修改，做安保功能。

​	因此在大多函数传递中，确定不会对原结构体及字符串进行修改，那么最好都在形参中添加const关键词，防止出现修改错误。

const使用

​	//const放在*号左侧 修饰p_a指针指向的内存空间不能修改,但可修改指针的指向

​	const int***** p_a **=** **&**a**;**

​	//*p_a = 100; //不可修改指针指向的内存空间

​	p_a **=** **&**b**;** //可修改指针的指向



​	//const放在*号的右侧， 修饰指针的指向不能修改，但是可修改指针指向的内存空间

​	int***** const p_b **=** **&**a**;**

​	//p_b = &b; //不可修改指针的指向

​	*****p_b **=** 100**;** //可修改指针指向的内存空间



​	//指针的指向和指针指向的内存空间都不能修改

​	const int***** const p_c **=** **&**a**;**

## 二级指针

### 二级指针输出特性

<!--day2的指针进阶中为一级指针相关内容-->

主调函数使用内存，被调函数开辟内存：指针输出特性

```
//被调函数,由参数n确定分配多少个元素内存
void allocate_space(int **arr,int n){
	//堆上分配n个int类型元素内存
	int *temp = (int *)malloc(sizeof(int)* n);
	if (NULL == temp){
		return;
	}
	//给内存初始化值
	int *pTemp = temp;
	for (int i = 0; i < n;i ++){
		//temp[i] = i + 100;
		*pTemp = i + 100;
		pTemp++;
	}
	//将内存空间直接给予实参指针，并且经过了初始化
	*arr = temp;
}
//打印数组，指针当作数组直接使用
void print_array(int *arr,int n){
	for (int i = 0; i < n;i ++){
		printf("%d ",arr[i]);
	}
	printf("\n");
}
//二级指针输出特性(由被调函数分配内存)
void test(){
	int *arr = NULL;
	int n = 10;
	//给arr指针间接赋值
	allocate_space(&arr,n);
	//输出arr指向数组的内存
	print_array(arr, n);
	//释放arr所指向内存空间的值
	if (arr != NULL){
		free(arr);
		arr = NULL;
	}
}
```

也可以利用二级指针，设计一个封装的free函数，即形参为二级指针，传递指针地址，那么此时对二级指针的释放与NULL化都为对原一级指针的操作，这样会使对一级指针的free更加简单化，直接调用即可。

多级指针利用，注意类型相同即可

### 二级指针的输入特性

二级指针输入特性(由主调函数分配内存) 

**主调函数开辟内存空间，传给副函数**，可以进行赋值也可以进行打印，（因为回传的是地址，所以可以直接做修改）

### 二级指针练习（文件读写）

#### 文件行数读取

```
int getfilelines(FILE *file)
{
	if(NULL == file)
	{
		return -1;
	}
	char buf[1024]={0}; //数组初始化
	int lines = 0;
	while (fgets(buf, 1024, file) != NULL)\
	{
		++lines;        //fgets访问每一行，得到行数
	}
	return lines;
}
```

得到文件行数之后，便可以根据此开辟内存空间，如：

`char **pcontent = malloc(sizeof(char* )* lines)` 

**利用二级指针开辟一级指针的内存，**每有一行需要读写，就额外安排一个一级指针指向该行。

**读完之后文件指针会指向末尾**，**所以要注意rewind的使用**

####  读取文件内容

```
void readFiledata(FILE *file, int lines, char ** contents)
{			//第一步：检验文件打开正确，内容和行数不为0
	if(NULL == file){
		return;
	}
	if(NULL == contents){
		return;
	}
	if(contens<=0){
		return;
	}
	/////////检验结束////////
	//创建缓冲区
	char buf[1024] = { 0 };
	int index = 0;    //行指针指向
	
	while(fgets(buf,1024,file) != NULL)
	{
		//printf("buf: %s\n", buf );
		int linelen = strlen(buf) + 1;	//得到行长度
		char *linecontent = malloc(sizeof(char)* linelen);	//开辟空间储存行内容
		contents[index++] = linecontent;  //将每一个一级指针都向原二级指针中存储
		memset(buf, 0, 1024);	//使用完后0初始化
	}
}
```

执行完之后二级指针内便有了一级指针指向每一行内容，进行简单的地址移位就可以使用改变行内容

#### 内存释放

```
void freeSpace(char **contents, int lines)
{
	for(int i = 0;i < lines; ++i)
	{
		free(contents[i]);   //每一个一级指针存储空间释放
		contens[i]=NULL;
	}
	free(contents);		//二级指针大空间释放
	contens = NULL;
}
```

**最后不要忘记关闭文件**

## 位运算

​	C提供位的逻辑运算符和移位运算符。在一个实际程序中，您可以使用一般的形式的整数变量或常量。例如不适用00011001的形式，而写为25或者031或者0x19.在我们的例子中，我们将使用8位数字，从左到右，每位的编号是7到0。

### 位逻辑运算符

####  **按位取反~**

一元运算符~将每个1变为0，将每个0变为1，如下面的例子：

**~(**10011010**)**

​	01100101

假设a是一个unsigned char，已赋值为2.在二进制中，2是00000010.于是-a的值为11111101或者253。请注意该运算符不会改变a的值，a仍为2。

unsigned char a **=** 2**;**   //00000010

unsigned char b **=** **~**a**;**  //11111101p

rintf**(**"ret = %d\n"**,** a**);** //ret = 2

printf**(**"ret = %d\n"**,** b**);** //ret = 253

负数反码，补码之间的转化：

![image-20231121113108925](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20231121113108925.png)

因此这里按位取反结果为-3.

#### **位与（**AND**）**: &

二进制运算符&通过对两个操作数逐位进行比较产生一个新值。对于每个位，**只有两个操作数的对应位都是1时结果才为1。**即两个操作数**有一个为0，就会产生0；**

   **(**10010011**)**  **&** **(**00111101**)**  **=** **(**00010001**)**

C也有一个组合的位与-赋值运算符：&=。下面两个将产生相同的结果：

val **&=** 0377

val **=** val **&** 0377

可以利用二进制末尾0和1决定奇偶性的特性，用位运算符算出该数的奇偶，如：

```
if（（number & 1) == 0)
{	//1的二进制前面都是0，所以会清为0，而只有奇数最后一位为1，结果才能为1，反之为0.由此进行判断
	printf("偶数");
}esle printf("奇数");
//或利用该特性，对数字进行清0；
number &= 0;
//0二进制都为0；因此会将number清0
```

#### **位或（**OR）**: |**

二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1.

​	**(**10010011**)**  **|** **(**00111101**)**  **=** **(**10111111**)**

C也有组合位或-赋值运算符： |=

val  **|=**  0377

val  **=**  val  **|**  0377

同  位与  相反

#### **位异或**

二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0.

​	**(**10010011**)**  **^** **(**00111101**)**  **=** **(**10101110**)**

C也有一个组合的位异或-赋值运算符： ^=

val **^=** 0377

val **=** val **^** 0377

即**上下操作位相同即为0，不相同则为1**

**可以有一个非常神奇的位运算来交换两个数的数值**

![image-20231121120512680](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20231121120512680.png)

### 移位运算符

#### **左移 <<**

​	左移运算符<<将其左侧操作数的值**每位向右**移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位（因为char型别占一个字节byte，八个二进制单位即八个位元bit）。在下面例子中，每位向左移动两个位置。

**(**10001010**)** **<<** 2				结果**(**00101000**)**

​	该操作将产生一个新位置，但是不改变其操作数。

​	

1 **<<** 1 **=** 2**;**	2 **<<** 1 **=** 4**;**	4 **<<** 1 **=** 8**;	**8 **<<** 2 **=** 32

**左移一位相当于原值*2.**

#### **右移 >>**

​	右移运算符>>将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。**对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。**

​	

//有符号值

**(**10001010**)** **>>** 2

**(**00100010**)**     //在某些系统上的结果值

**(**10001010**)** **>>** 2

**(**11100010**)**     //在另一些系统上的结果

//无符号值

**(**10001010**)** **>>** 2**(**00100010**)**    //所有系统上的结果值

#### **用法：移位运算符**

​	移位运算符能够提供快捷、高效（依赖于硬件）对2的幂的乘法和除法。

| number << n | number乘以2的n次幂                     |
| ----------- | -------------------------------------- |
| number >> n | 如果number非负，则用number除以2的n次幂 |
