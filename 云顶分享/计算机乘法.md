# 计算机乘法

**<u>==基础==</u>**：

由于没有找到好的带符号位数例子，所以这里以此为例

![img](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/1504628-20200415225008490-312401728.png)

下方四种计算机乘法都是将上面的这种左移转变为右移来实现的，而带上符号位正好可以将无论是整数还是小数都通过上面这种方式实现乘法。

以下都以x=0.110111，y=0.101110为例

## 原码一位乘

![image-20240205154323682](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240205154323682.png)

![在这里插入图片描述](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/a4077c2ac1d8446da6548626faccabb9.png)

## 原码两位乘

有触发器C，保存缺数

由于每次移动两位，所以要选择数值位n为偶数个为乘数，乘数取双符号位，这种情况共做(n/2)+1步，最后一步不移位；若乘数的数值位n为奇数，乘数取单符号位，每步处理2位，恰好做(n+1) / 2步，最后一步移一位。——这里实际上就是用符号位使得乘数位数为偶数，使得移到最后不会漏下一位。

000部分积加0，    右移两位，c变为0

001部分积加|x|， 右移两位，c变为0

010 部分积加|x|， 右移两位，c变为0

011部分积加2|x|，右移两位，c变为0

100部分积加2|x|，右移两位，c变为0

****

101部分积减|x|， 右移两位，c变为1

110部分积减|x|， 右移两位，c变为1

111 部分积加0，     右移两位，c变为1
以上两个原理是+3x换为+4x-x，这样只需要-x再C积一位右移两位就相当于了x×4，可对比上面的基础部分，部分积右移两位，**<u>关键是x并没有右移</u>**，所以相当于x乘4（左移两位）

例：

![](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/2c34e75cb9784387bd7ea666dc97271e.png)

## 硬件实现

![image-20240129225632883](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129225632883.png)

A寄存器中n+1位，最高位用来保存进位，保存部分积，并将其向Q乘数寄存器中传递

被乘数保存在X寄存器中，保持不变

Q乘数寄存器，进行移位和加控制，与计数器C对移位次数进行计数，移位n次后说明乘计算结束。

S符号位，将两个乘数符号位进行异或计算。

简化逻辑：当乘数最后一位n不是0时，控制门才会打开放进X中的被乘数，随后在加法器中Q被积数与新被积数相加，送到A中，如果乘数最后一位n是0，那么控制门不打开，直接移位，因此是记录移位的次数来判断是否乘法结束，而不是乘法进行的次数

# 补码乘法

与上面的原码乘法方法其实相差不大，只不过这里是用补码先求出两者相乘结果的乘法，有了结果补码后就可以得到对应的原码（有点多此一举）

因此准备工作比较多，开始前要得出两个乘数的补码，以及一个乘数相反数的补码

## 补码一位乘

A.D. Booth提出的算法：相乘二数用补码表示，它们的符号位与数值位一起参与乘法运算的过程，直接得出用补码表示的乘法结果，且正数和负数同等对待。这种算法被称之为布斯算法。

与原码一位乘递推公式同理。

可证明：
                          n
[X∗Y]~补~=[X]~补~ ∗ ∑(Y~i+1~−Y~i~)2^−i^
                         i=1
 (符号位参加运算)
由公式得出补码一位乘法的运算规则：
(1)如果Y~n+1~=Y~n~，部分积加0，部分积算术右移一位；
(2)如果Y~n~Y~n+1~=01，部分积加[X]~补~，部分积算术右移一位；
(2)如果Y~n~Y~n+1~=10，部分积加[−X]~补~，部分积算术右移一位。
重复进行n+1步，但最后一步不移位。

例：

![在这里插入图片描述](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/a1c29af22521418d8e4e04334f10a257.png)

**所以布斯算法的算法过程为n+1次的”判断→加减→右移“的循环，右移的次数为n次**

清零实际就是因为留下的最后一位为符号位，所以直接舍去，不进行右移

## 补码两位乘

与原码两位乘类似，不过这里的规则表的推导非常复杂，hhhhhh所以想要非常直观地得到递推公式理解的话，可以看以下一个论文 QAQ

[补码两位乘公式论文](https://www.docin.com/p-427763344.html)

运算规则：

1.当n为偶数时，则采用**双符号位**，乘法运算过程中的总循环次数为n/2+1。最后一次不右移，因为最后一次是仅仅对符号位的运算。
2.当n为奇数时，则采用**单符号位**，乘法运算过程中的总循环次数为(n+1)/2。最后一次右移一位，因为最后一次是对符号位和最高数值位的运算，符号位的原位不需要右移。

| y~i-1~y~i~ y~i+1~ | 操作                      |
| ----------------- | ------------------------- |
| 000               | 部分积直接右移两位        |
| 001               | 部分积加[x]补，右移两位   |
| 010               | 部分积加[x]补，右移两位   |
| 011               | 部分积加2[x]补，右移两位  |
| 100               | 部分积加2[-x]补，右移两位 |
| 101               | 部分积加[-x]补，右移两位  |
| 110               | 部分积加[-x]补，右移两位  |
| 111               | 部分积直接右移两位        |

例：

![](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/625d6b1cd5d64d17912ec3a5b8a27c06.png)

## 硬件实现

![在这里插入图片描述](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/20200714095918765.png)

与原码乘法硬件实现原理类似，可参考原码硬件实现部分理解