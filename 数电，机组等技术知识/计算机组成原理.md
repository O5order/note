# 计算机组成原理

[TOC]

## 第一章计算机系统简介

硬件，计算机的实体,如主机、外设等
软件，系统软件由具有各类特殊功能的信息（程序）组成，又分为**系统软件**（**语言处理程序，操作系统，服务型程序，数据库管理系统，网络软件**）和**应用软件**

冯诺依曼计算机特点：

1.运算器，控制器，存储器，输入设备，输出设备五大部件组成

2.指令和数据以同等地位存于存储器，可按地址寻访

3.指令和数据用二进制表示

4.指令由操作码和地址码组成

5.存储程序

6.以运算器为中心

系统复杂性管理的方法：层次化（被设计的系统划分为多个模块或子模），模块化（有明确定义的功能和接口），规则性（模块更容易被重用）

指令和数据都是保存在存储器中的

### 存储器基本组成

存储体-》存储单元-》存储元件

存储元件存储一个二进制代码，因此一个存储单元可以存储一传二进制代码，这段二进制代码就是一个存储字，称这串二进制代码的位数为存储字长

地址寄存器MAR存储器地址寄存器，反映存储单元的个数，位数对应存储单元的个数

数据寄存器MDR存储器数据寄存器，反映存储字长，一般为字节的2次幂的整数倍

### 运算器

核心是算术逻辑单元，运算器包含多个通用寄存器，用于暂存操作数和中间结果，如累加器（ACC）乘商寄存器（MQ）操作数寄存器（X）变址寄存器（IX）基址寄存器（BR）其中前三个寄存器是必备的。

运算器内还有程序状态寄存器（PSW）也称标志寄存器，存放ALU运算得到的标志信息或处理机的状态信息，比如结果是否溢出，有无产生进位或错位，结果是否为负等

### 控制器

由程序计数器（PC）存放当前欲执行指令的地址有计数功能，用于取指令；指令寄存器（IR）存放当前欲执行的指令，用于分析指令；控制单元（CU）用于执行指令，组成

****

一般将运算器和控制器集成到同一个芯片上，称为中央处理器（CPU)。CPU和主存储器共同构成主机，而除主机外的其他硬件装置（外存、IO设备等）统称为外部设备，简称外设。
**CPU和主存之间通过一组总线相连，**总线中有地址、控制和数据3组信号线。MAR中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元:控制线中有读/写信号线，指出数据是从CPU 写入主存还是从主存读出到CPU，根据是读操作还是写操作来控制将MDR 中的数据是直接送到数据线上还是将数据线上的数据接收到MDR中。

注意这里的MAR较为特殊，属于存储器中的一部分，但一般也集成在CPU中

综上，运算执行顺序：首先读取指令存放地址，即访问PC--------》然后寄存地址到MAR-------》通过寄存的地址访问存储体--------》地址的信息在存储体中找到后寄存于MDR中--------》将信息传递到控制器的IR中，解析指令---------》解析完毕后到达CU执行指令---------》然后交给运算器执行

具体步骤如下：

- 将程序通过输入设备送至计算机  

- 程序首地址→PC

- 启动程序运行

- 取指令PC→MAR→M→MDR→IR

- 分析指令OP(IR)→CU

- 执行指令Ad(IR) →MAR→ M→MDR→ACC

  ### 性能对比

1.机器字长：与CPU一次能处理数据的位数与CPU中的寄存器位数有关
2.运算速度：通过以下权衡

- 主频，CPU时钟脉冲频率

- 核数，每个核支持的线程数

- 吉普森法 TM = （i从1加到n求和）fi ti;

- CPI平均执行一条指令所需时钟周期数

- MIPS每秒执行百万条指令

- MFLOPS 每秒浮点运算次数

![image-20240123111850347](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240123111850347.png)

主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数×字长(如512K×16位）来表示存储容量。其中，MAR的位数反映了存储单元的个数，MDR的位数反映了存储单元的字长。例如，MAR为16位，表示21=65536，即此存储体内有65536个存储单元(可称为64K内存，1K=1024)，若MDR为32位，表示存储容量为64K×32位。

### 附加注言

- 编译程序是先完整编译为低级语言再经过微程序变为机器语言后运行的程序，如C、C++等;解释程序是一句一句翻译且边翻译边执行的程序，如JavaScript、Python等。由于解释程序要边翻译成机器语言边执行，因此一般速度较编译程序慢。

- 8位计算机表明计算机字长为8位,即一次可以处理8位的数据;而用16位表示地址码的长度，即该机器有2^16^=65536个地址空间。

- 数据库系统是指在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员构成，其中数据库管理系统是系统软件。再细分的数据库系统则不是系统软件

- 相联存储器既可以按地址寻址又可以按内容（通常是某些字段)寻址，为与传统存储器区别，又称按内容寻址的存储器。

- 在计算机多层次结构中，上下层是可以分割的，且上层是下层的功能实现。此外，上层在下层的基础上实现了更加丰富的功能，仅有下层而没有上层也是可以的。可以说下层是上层的基础

- 虽然指令和数据都以二进制形式存放在存储器中，CPU可以根据指令周期的不同阶段来区分是指令还是数据，通常在取指阶段取出的是指令，在执行阶段取出的是数据。需要清楚的是，CPU只有在确定取出的是指令后，才会将其操作码送去译码，因此不可能依据译码的结果来区分指令和数据。

- 机器字长、指令字长和存储字长，**都是字节的整数倍**，三者在数值上可以相等也可以不等，视不同机器而定。

  **指令字长**是一个指令字中包含的二进制代码的位数

  **存储字长**是一个存储单元中的二进制代码的位数。

  **存储字长**等于MDR的位数，而数据字长是数据总线一次能并行传送信息的位数,它可以不等于MDR的位数。

  **指令字长**一般取存储字长的整数倍，若指令字长等于存储字长的两倍，则需要两个访存周期来取出一条指令。

- **计算机的位数，即机器字长，多少位计算机就指的是机器字长**也就是计算机一次能处理的二进制数的长度。（与CPU密切相关，内部字节要统一）要注意的是，**操作系统的位数**是操作系统可寻址的位数，它**与机器字长不同。**一般情况下可通过寄存器的位数来判断机器字长。

- 一般来说，单独说字或字长时，往往指的是 机器字，其字长即为计算机一次能直接处理的二进制数据的位数，这个主要取决于CPU内部数据总线的位宽，也就是说一次能传输多少数据到CPU中进行处理。比如8086的CPU内部数据总线的宽度为16位，即说明8086是16位机，所以其字长为16。同理，32位机其机器字长为32，64位机其机器字长为64.

  当然有时候还会在“字长”前面加上一些修饰语，比如——指令字长、储存字长等。
  其中指令字长为指的是机器指令中二进制代码的总位数，指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数，不同的指令的字长是不同的。
  原文链接：https://blog.csdn.net/ZHOU_YONG915/article/details/120755355

  存储单元一般指的是广义的按字寻址即机器字

- 时钟周期是CPU主频的倒数，因此与CPI无关

- 吞吐率对于计算机性能综合评价效果较好

- 总线只能减少信息传输线的条数

- 同步通信比异步通信速率快，因为低等级速率复接为高等级时异步方式存在自身时钟精度的限制和信息监控字节不易加入的问题，而**同步方式因为字节位置固定，有丰富的复接开销字节和传输运行字节，方便复接成高等级速率**。

- **编译程序与汇编程序的区别**:若源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。

## 第二章系统总线

### 一、分类：

1.片内总线    芯片内部的总线

2.系统总线     计算机各部件之间的信息传输线

- 数据总线     双向与机器字长、存储字长有关

- 地址总线     单向与存储地址、IO地址有关

- 控制总线     有出  有入（控制中断停止）

3.通信总线         用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等)之间的通信，传输方式包括串行通信总线，并行通信总线

### 二、总线特性

1.机械特性     尺寸、形状、管脚数及排列顺序
2.电气特性     传输方向和有效的电平范围
3.功能特性     每根传输线的功能  包括地址，数据，控制
4.时间特性     信号的时序关系

### 三、总线的性能指标

1.总线宽度        数据线的根数
2.标准传输率       每秒传输的最大字节数(MBps)
3.时钟同步/异步           同步、不同步
4.总线复用          地址线与数据线复用
5.信号线数         地址线、数据线和控制线的总和

6.总线控制方式         突发、自动、仲裁、逻辑、计数
7.其他指标          负载能力

### 四、总线结构

有单，双，三，四总线结构

双总线有主存总线，IO总线

三总线有主存总线，IO总线，直接内存访问（DMA）总线

主存总线用于在CPU和内存之间传送地址、数据和控制信息。I/O总线用于在CPU和各类外设之间通信。DMA总线用于在内存和高速外设之间直接传送数据。
三线优点:提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量。
三线缺点:系统工作效率较低。

### 五、总线控制

一、总线判优控制

1.基本概念

- 主设备(模块)        对总线有控制权
- 从设备(模块）     响应从主设备发来的总线命令
- 总线判优控制包括分布式和集中式（包括独立请求方式  计数器定时查询   链式查询）

![image-20240123163420161](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240123163420161.png)

优先级由BG的查询顺序决定，先查询接口0，如果接口0不发出BR，BS则继续向后访问，直到遇到需要访问的接口，发出BS，BR，总线同意后顺利进行。

****

计数器定时查询方式

无BG线，取而代之的是计数器（在总线控制部件中）和一条设备地址线，计数器初始为x，每次查询计数器对应数字的IO接口，没有发出请求就加1，直到要发出请求，之后同上相同。

****

独立请求方式

无BS，取而代之的是每个IO接口有两条独立的BR和BG线，总线控制部件中多一个排队器

****

总线通信控制

1.目的：解决通信双方协调配合问题

2.总线传输周期
申请分配阶段        **主模块申请**，总线仲裁决定

寻址阶段      主模块向从模块**给出地址**和**命令**
传数阶段      主模块和从模块**交换数据**
结束阶段      主模块**撤消有关信息**

3.四种方式

同步通信：由**统一时标**控制数据传送

异步通信：采用应答方式，没有公共时钟标准

半同步通信：同步，异步结合

分离式通信：充分挖掘系统总线每个瞬间的潜力

![image-20240123165900318](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240123165900318.png)

![image-20240123170344036](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240123170344036.png)

(4)半同步通信(同步、异步结合)
同步：发送方用系统时钟前沿发信号
            接收方用系统时钟后沿判断、识别
异步：允许不同速度的模块和谐工作
            增加一条“等待”响应信号WAIT

工作流程如下：![image-20240123171157847](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240123171157847.png)

主模块要不断检测WAIT信号，在从模块准备好数据后，WAIT设备会从低电平变为高电平，主设备检测到WAIT的高电平，进行读命令，最后关闭地址传输

上述三种通信的共同点

一个总线传输周期（(以输入数据为例)

- 主模块发送地址和命令    占用总线
- 从模块准备数据      不占用总线
- 从模块向主模块发数据     占用总线

分离式通信

子周期1
主模块申请占用总线，使用完后即放弃总线的使用权
子周期2
从模块申请占用总线，将各种信息送至总线上

特点：各模块有权申请占用总线。采用同步方式通信，不等对方回答。各模块准备数据时，不占用总线。总线被占用时无空闲

## 第三章存储器

### 概述总括

分类：

1.存储介质分

半导体存储器    TTL，MOS    ——易失（断电后即消失）

磁表面存储器   磁头，磁载体

磁芯存储器     硬磁材料，环状元件

光盘存储器     激光，磁光材料

2.存取方式分

- 存取时间与物理地址无关（随机访问）     

随机存储器RAM（程序执行过程中可读可写）

- 只读存储器ROM，一旦写入固定不变不会丢失，因此它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。

- 存取时间与物理地址有关（串行访问）

顺序存取存储器 ——磁带，直接存取存储器——磁盘

3.按计算机中作用分

- 主存储器RAM（分为动态和静态），ROM分为（MROM，PROM，EPROM，EEPROM）

- Flash Memory
- 高速缓冲存储器（Cache）

- 辅助存储器

存储器层次结构

​                  -寄存器-          在CPU中，还有部分在IO端中

​               -----缓存-------         部分在CPU中

​           -------- 主存--------

​        -----------磁盘------------

​     --------------光盘---------------

------------------磁带---------------------

越往上速度越快，容量越小，价格越贵



缓存——主存（主要解决的是速度问题），主存——辅存（主要解决容量问题）两层次，由于主存辅存采用软硬件相结合的方式，因此为虚拟存储器由主存辅存（虚地址，逻辑地址）；而主存储器就是实地址。使用虚拟存储器是为了解决( ==扩大存储器容量==  )问题，存储管理主要由( ==硬件和操作系统==  )实现。

### 主存

经过地址总线到MAR，再经过译码器和驱动器后传递到存储体，随后到达读写电路（控制方向），有控制电路（发送读或写电路到读写电路），之后就是MDR然后是数据总线

注意：MAR和MDR集成在CPU上

主存中存储单元地址分配：大端大尾方式，小端小尾方式

一个字   = （字长 / 8bit）字节

主存技术指标

存储容量  =  存储字数×字长(如1M×8位)。单位换算:1B(Byte，字节)=8b (bit，位)。

存取速度（涵盖存储器的访问时间，读出时间和写入时间。存取周期即两次独立的存储器操作所需的最小间隔时间，这包括了写周期和读周期。存储器的带宽（多少位每秒））

注意：存取时间不等于存取周期，通常存取周期大于存取时间。这是因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可达Tm=2Ta，因为存储器中的信息读出后需要马上进行再生。

存储器进行一次“读”或“写”操作所需的时间称为存储器的访问时间（或读写时间），

而**连续启动两次独立的“读”或“写”操作（如连续的两次“读”操作）所需的最短时间**，称为存取周期（或存储周期）。

单位成本

### 半导体存储芯片

结构：

​              ----------------------------------------------------------------------------

地          |																			              |     数

址		  |            译码驱动     存储矩阵      读写电路                     |     据

线          |																					      |     线

片选线   ---------------------------------------------------------------------------    读/写控制线

地址线是单向的           数据线是双向的                芯片容量

​       10条                                     4条                       1K×4位

​       14条                                    1条                      16K×1位

以上为芯片容量根据地址线和数据线的数量算得结果

片选线中含有使能线CS非（使设备能否正常工作）和选中线CE非（选哪个芯片）

  读/写控制线：1.WE非通过低电平写，高电平读操作

​                           2.OE非允许读，WE非允许写

译码驱动方式

1.线选法

只有一个地址译码器和读写控制电路（读写选通），存储内容极少

2.重合法（双译码方式）

将地址拆分为两部分XY地址，分别编译存储或读取

![image-20240124103058698](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240124103058698.png)

### 随机存取存储器

#### 1.静态RAM（SRAM）

通常把存放一个二进制位的物理器件称为存储元，它是存储器的最基本的构件。地址码相同的多个存储元构成一个存储单元。若干存储单元的集合构成存储体。
静态随机存储器（SRAM)的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此即使信息被读出后，它仍保持其原状态而不需要再生（非破坏性读出)。
SRAM的存取速度快，但集成度低，功耗较大，价格昂贵，一般用于高速缓冲存储器。

如下为工作原理及示例：

![image-20240124105223482](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240124105223482.png)

![image-20240124110242636](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240124110242636.png)

这里将4列合并为1列，即将64列转换为16大列，然后通过4条列地址译码线和6条行地址译码线实现每个地址的读写

#### 2.动态RAM（DRAM）

由于其内部电路原理，读出信息与原存信息相反，但是写入与输入信息相同![image-20240124112722559](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240124112722559.png)

与SRAM的存储原理不同，DRAM利用存储元电路中栅极电容上的电荷来存储信息，DRAM 的基本存储元通常只使用一个晶体管，所以它比 SRAM 的密度要高很多。

相对于SRAM来说，DRAM具有容易集成、位价低、容量大和功耗低等优点，但DRAM的存取速度比SRAM的慢，一般用于大容量的主存系统。

![image-20240124112831698](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240124112831698.png)

DRAM电容上的电荷一般只能维持1一2ms，因此即使电源不断电，信息也会自动消失。为此，每隔一定时间必须刷新，通常取2ms，称为刷新周期。因此有刷新放大器去保持刷新

存储器芯片由存储体、IO读写电路、地址译码和控制电路等部分组成。

##### 动态RAM刷新

1.集中刷新

刷新的时间在一个集中时间段，因此举例：128×128矩阵为例，刷新时间间隔为2ms，那么一共有4000个周期，其中3872个周期（1936us）可以供使用，另外的128个周期（64us）为死区，死时间率为128/4000=3.2%，永远无法供使用，只能用于刷新。

2.分散刷新

T=T读写+T刷新，每个周期都要进行刷新，周期加长了，无死区可是浪费了性能。

3.异步刷新（二者结合）

每隔15.6us刷新一行，这样刚好2ms刷新一次，但是刷新可以安排在指令译码阶段，这样不会出现死区，也不会浪费性能。

#### 静态动态比较

|          | DRAM（主存） | SRAM（缓存） |
| :------: | :----------: | :----------: |
| 存储原理 |     电容     |    触发器    |
|  集成度  |      高      |      低      |
| 芯片引脚 |      少      |      多      |
|   功耗   |      小      |      大      |
|   价格   |      低      |      高      |
|   速度   |      慢      |      快      |
|   刷新   |      有      |      无      |

### 只读存储器（ROM）

1.掩模ROM（MROM）

厂家将信息写好，不可擦写，只可读

行列选择线交叉处有MOS管为“1”行列选择线交叉处无MOS管为“O”，因此为厂家生产时决定。

2.PROM（用于一次性编程）

行线和列线中有一条熔丝，编程时通过控制熔丝烧断达到目的。但是一次编程后无法更改

3.EPROM（多次性编程）紫外线擦写

N型沟道浮动栅MOS电路（具体细节可参考数电MOS管部分知识）

4.EEPROM（多次性编程）

电可擦写，局部擦写，全部擦写

5.Flash Memory（闪速型存储器）

而Flah比EEPROM快，且具备RAM功能

EPROM   价格便宜，集成度高

EEPROM    电可擦洗重写

### 存储器与CPU的连接

1.存储器容量的扩展

- 位扩展（增加存储字长——位的扩展）

  多片存储芯片并用（一定要同时进行工作，因此多个芯片的选通线和IO线要连在一起）

- 字扩展

  多片存储芯片并用（但是这里芯片不能一起工作，否则数据线会混乱，每次只能一个芯片在工作）

  因此多出来的地址线经过译码器做片选线，选择对应的存储芯片

- 字，位同时扩展

  先看位扩展，把对应数量的芯片连在一起当作一组，然后正常进行字扩展即可

连接顺序

1.地址线连接

2.数据线连接

3.读写命令线连接

4.片选线连接

5.合理选择存储芯片

6.其他——时序，负载

注意CPU上的MREQ端一定要连接，这是CPU上判断是否从存储器上拿的依据端口

### 存储器校验

![image-20240124155816510](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240124155816510.png)

编码的最小距离：任意两组合法代码之间二进制位数的最小差异

编码的纠错，检错能力与编码的最小距离有关

L-1=D+C (D大于等于C)
L——编码的最小距离L=3
D——检测错误的位数且具有一位纠错能力
C——纠正错误的位数

汉明码组成——奇偶检验，分组检验

![image-20240124164321748](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240124164321748.png)

组成汉明码的三要素
汉明码的组成需增添﹖位检测位
2^k^>n+k +1，n为原二进制代码个数（数据个数），可计算出k组个数（检验码个数）



检测位的位置?
**2的i次** ( i=o，1，2，3 ，… )

检测位的取值?                   
检测位的取值与该位所在的检测“小组“承担的奇偶校验任务有关

C1检测的g1小组包含第1，3，5，7，9，11，…位置的二级制编码为X.….XXX1

C2检测的g2小组包含第2，3，6，7，10，11，…位置的二级制编码为X.…XX1X

C3检测的g3小组包含第4，5，6，7，12，13，…位置的二级制编码为X...X1XX

gi小组独占第2^i-1^位位置的二进制编码为0...10.….0

gi和 gj小组共同占第2^i-1^+2^j-1^位
位置的二进制编码为0...010...010...0
gi、gj和gl小组共同占第2^i-1^+2^j-1^次+2^l-1^次位位置的.二进制编码为0...010..010...010...0

例子：

![image-20240124170514309](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240124170514309.png)

这里偶检验，C1组为1357，保持偶数，C1为0，C2组为2367，保持偶数，C2为1。同理，C4为0

汉明码纠错：将检验码和数据拆分，根据奇偶检验看检验码是否出错，从而找出有问题的数据并进行纠正。

### 提高访存速度的措施

采用高速器件
采用层次结构Cache -主存

调整主存结构
1.单体多字系统（增加存储器的带宽）

2.多体并行系统——高位交叉，顺序编址

原理：存储器划分为多组，通过体内地址，体号实现对多组存储器同时进行访问

但是由于地址存放原则（从低位顺序存取），因此带宽不能很好的提升，只能提升容量

低位交叉

如下为原理图

![image-20240124173149608](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240124173149608.png)

和上面的高位交叉鲜明对比的就是每组体号在低位，这样实现了带宽的提升。

3.高性能存储芯片

1.SDRAM（同步DRAM）

（1）在系统时钟的控制下进行读出和写入——在系统时钟的控制下进行读出和写入，CPU无须等待
(2)RDRAM
由Rambus开发，主要解决存储器带宽问题
(3)带Cache的 DRAM

### 高速缓冲存储器

避免CPU“空等”现象
CPU和主存（DRAM）的速度差异——通过缓存Cache（容量小，速度高）解决

依据程序访问的局部性原理：当前正在使用的指令和数据短时间内会再使用

因此当前在使用和相邻的数据指令放在Cache中

- Cache工作原理：

缓存Cache块和主存块互相对应——块与块对应

![image-20240125092938388](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240125092938388.png)

标记就是缓存块中对应的主存块

(2)命中与未命中
缓存共有C块，主存共有M块

M>>C
命中：主存块调入缓存，主存块与缓存块建立了对应关系，用标记记录与某缓存块建立了对应关系的主存块号
未命中：主存块未调入缓存，主存块与缓存块未建立对应关系

(3 ) Cache的命中率：CPU欲访问的信息在 Cache 中的比率

命中率与Cache的容量与块长有关v

一般每块可取4~8个字，块长取一个存取周期内从主存调出的信息长度

(4) Cache ——主存系统的效率

效率e与命中率有关

e =访问Cache的时间/平均访问时间×100%

平均访问时间就是Cache命中率×访问Cache时间+未命中率×访问主存的时间

****

- Cache结构：

![image-20240125094918878](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240125094918878.png)

- Cache读写操作：

CPU发出访问地址，Cache判断是否命中，命中读出，未命中判断Cache是否满，满则执行替换算法将新的主存块调入Cache中，否则就直接从主存中读取。

写操作由于要保持Cache和主存的一致性，因此有两种方法：

写直达法(Write - through)
写操作时数据既写入Cache又写入主存
写操作时间就是访问主存的时间，Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现。

写回法( Write - back)
写操作时只把数据写入Cache而不写入主存，当Cache数据被替换出去时才写回主存

- Cache改进

(1)增加Cache 的级数
片载(片内）Cache        片外Cache
(2)统一缓存和分立缓存
指令Cache        数据Cache
与指令执行的控制方式有关         是否流水          如：
Pentium      8K指令Cache      8k数据Cache
PowerPC620     32K指令Cache      32K数据Cache

- Cache ―主存的地址映射

1.直接映射

![image-20240125101503823](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240125101503823.png)

![image-20240125102106051](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240125102106051.png)

![image-20240125102350447](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240125102350447.png)

某一主存块j按模Q映射到缓存的第i组中的任一块，是前二者的结合更为常用

n号主存单元所在的主存块代表第n个字节，第n块主存块一定可以存到第n组Cache中

- 替换算法

1.先进先出算法

2.近期最少使用算法——局部性原理有关

在一段时间内，整个程序的执行仅限于程序的某一部分，相应地，程序访问的存储空间也局限于某个内存区域。主要分为两类：

时间局部性：如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。
空间局部性：是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。

小结
直接： 某一主存块只能固定映射到某一缓存块

全相联：某一主存块能映射到任一缓存块

组相联： 某一主存块只能映射到某一缓存组中的1组

### 辅助存储器

1.特点   不直接与CPU交换信息

2．磁表面存储器的技术指标
(1)记录密度   道密度D~t~、位密度D~b~
(2)存储容量     C=n ×k × s
(3)平均寻址时间    寻道时间＋等待时间
辅存的速度：寻址时间   磁头读写时间
(4)数据传输率 ：   D~r~=D~b~×V
(5)误码率  出错信息位数与读出信息总数的比值

1.硬磁盘存储器的类型
(1)固定磁头和移动磁头(2)可换盘和固定盘

2.硬磁盘存储器结构

主机《——》磁盘控制器《——》磁盘驱动器《——》盘片
磁盘驱动器实现磁盘上磁头的控制，进行读写操作

(2)磁盘控制器

- 接收主机发来的命令，转换成磁盘驱动器的控制命令·
- 实现主机和驱动器之间的数据格式转换
- 控制磁盘驱动器读写
- 磁盘控制器是主机与磁盘驱动器之间的接口 ——对主线通过主线，对硬盘直接控制

磁盘上访问信息的最小物理单位是 （ ==扇区== ）

软磁盘存储器——速度低，便宜

光盘存储器
采用光存储技术     利用激光写入和读出
第一代光存储技术    采用非磁性介质，不可擦写

第二代光存储技术      采用磁性介质，可擦写
2.光盘的存储原理
只读型和只写一次型   热作用   （物理或化学方法）
可擦写光盘        热磁效应

虚拟内存内存调度方式有分页式、段式、段页式3种

页式调度是**将逻辑和物理地址空间都分成固定大小的页**

另一种划分可寻址的存储空间的方法称为分段

## 第四章输入输出系统

发展

1.早期     分散连接，CPU和IO设备 串行工作   

2.接口模块和DMA阶段        总线连接，CPU和IO设备并行工作  中断方式，DMA方式

3.具有通道结构的阶段

4.具有IO处理器的阶段

1.1/O 软件

(1)I/O指令   CPU  指令的一部分
操作码  命令码  设备码
(2)通道指令   通道自身的指令
指出数组的首地址、传送字数、操作命令

如IBM/370通道指令为64位
2.I/O硬件
设备       I/O接口
设备      设备控制器     通道

### IO设备与主机的联系方式

1.I/O设备编址方式
(1)统一编址        用取数、存数指令
(2)不统一编址         专门的IO指令

2.设备选址

用设备选择电路识别是否被选中

3.传送方式

串行和并行

4.联络方式

![](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20240125112456.png)

5.连接方式

（1）辐射式连接

每台设备都有一套控制线路和一组信号线——不便于增删设备

（2）总线连接

接入接口——便于增删设备

****

6.IO设备与主机信息传送的控制方式

（1）程序查询方式

现行程序运行，CPU向IO发读指令，随后CPU读取IO状态，**<u>若IO未准备就绪就重新读取，直到准备就绪后从IO接口读一个字到CPU</u>**，CPU就会同时向主存写入一个字，同时检查是否完成，未完成就重复这个过程直到结束。

划线处很大程度上浪费了CPU性能

（2）程序中断方式

IO工作：自身准备（此时CPU不进行查询）与主机交换信息时向CPU发送中断信号，CPU中断现行程序，读一个字到CPU，CPU就会同时向主存写入一个字，同时检查是否完成，未完成就重复这个过程直到结束。这样的方式CPU在IO设备准备数据时进行其他程序，没有空等踏步。

但是这样操作仍需要对现场的修复及保护，需要CPU传输数据，仍占用很多CPU效能

（3）DMA方式

主存和IO之间有一条直接数据通道

CPU执行现行程序直到遇到IO命令，启动IO，IO进行准备，在准备完后DMA发出请求，暂时窃取（挪用）CPU一个存取周期去实现IO与主存之间的传送，（这时CPU无法访问内存，不能使用总线但仍然可以执行不需要内寸的程序）随后CPU继续执行现行程序，IO继续进行准备，然后再重复这个过程。

这样做实现了CPU和IO设备的并行。

### IO设备

主机《——》IO接口《——》设备控制器，机、电、磁、光部分

外部设备分三类：

1.人机交互设备：键盘鼠标打印机显示屏

2.计算机信息存储设备：磁盘、光盘、磁带

3.机一机通信设备：调制解调器等

输入设备：键盘鼠标触摸屏

输出设备：显示器打印机

A/D ：模拟/数字信号转换器

### IO接口

1.总线连接的IO接口电路

设备选择线，命令线，状态线，数据线，IO总线、

组成：

选址功能——设备选择电路

传送命令的功能——命令寄存器、命令译码器
传送数据的功能——数据缓冲寄存器DBR
反映设备状态的功能——设备状态标记
完成触发器D

工作触发器B

中断请求触发器INTR

屏蔽触发器MASK

![image-20240125155212738](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240125155212738.png)

接口类型：1.按数据传送方式分类：串行接口，并行接口

2.按功能选择的灵活性分类：可编程接口，不可编程接口

3.按通用性分类：通用接口，专用接口

4.按数据传送的控制方式分类：中断接口，DMA接口

### 程序查询方式

程序查询流程：检查状态标记，准备就绪就进行处理设备反则就查询其他状态标记处理其他的设备。

保存寄存器内容：

设置计数器值，计算IO和内存之间传输的数据量（可设为n或-n）直到归零那么程序执行结束

如下：

地址线输入，设备选择电路确定该设备后，再接送到启动命令，才会发送信号。左边D在准备就绪后才会发送高电平给CPU，启动设备将数据传入DBR，CPU占据数据线进行传输

![image-20240125164807649](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240125164807649.png)

### 程序中断方式

程序中断方式的接口电路
1.配置中断请求触发器（INTR=1有请求）和中断屏蔽触发器（MASK=1被屏蔽）

D完成触发器（由设备本身控制），D和MASK经过与门连到INTR

2.排队器

硬件在CPU内或在接口电路中（链式排队器)

软件详见第八章

链式排队器：优先级按降序排列

3.中断向量地址形成部件

入口地址由软件产生——第八章

硬件向量法——**<u>由硬件产生向量地址，再由向量地址找到入口地址</u>***因此中断向量地址是中断服务例行程序入口地址的地址

排队器输出——》中断向量地址形成部件（设备编码器）——》向量地址

譬如打印机服务程序入口地址为200，那么硬件产生向量地址12H，再找到入口地址。

4.程序中断方式接口电路的基本组成

![image-20240125172434021](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240125172434021.png)

1.CPU响应中断的条件和时间

**CPU响应中断**后，输出中断响应信号，自动将状态标志 寄存器 FR或EFR的内容压入 堆栈 保护起来，然后将FR或EFR中的中断标志位IF与陷阱标志位TF清零，从而自动关闭外部硬件中断。

(1)条件
允许中断触发器EINT=1
用开中断指令将EINT置“1”
用关中断指令将EINT置“0”或硬件自动复位

(2)时间
当D=1(随机）且MASK=0时在每条指令执行阶段的结束前
CPU发中断查询信号（将INTR置“1”）

中断服务程序流程

（1）保护现场

对于程序断点的保护——中断隐指令完成，寄存器内容的保护——进栈指令，软件执行程序完成

（2）中断指令——对不同的IO设备具有不同内容的设备服务

（3）恢复现场——出栈指令

（4）中断返回——中断返回指令

****

单重中断——不允许中断现行的中断服务程序

多重中断——允许级别更高的中断源中断现行的中断服务程序

单重：取指令，执行指令，判断是否中断

中断周期：中断响应   程序断点进栈    关中断     向量地址→PC

中断服务程序：保护现场，设备服务，恢复现场，开中断中断返回

多重：中断之前的过程相同，但是中断服务程序处不同，顺序如下

中断服务程序：保护现场，开中断，设备服务，恢复现场，中断返回

宏观上 CPU 和I/O并行工作
微观上CPU 中断现行程序为IO服务

### DMA方式

1.DMA和程序中断两种方式的数据通路

![image-20240125175540612](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240125175540612.png)

2.DMA与主存交换数据的三种方式
（1）停止 CPU 访问主存

控制简单，但是CPU处于不工作状态或保持状态，未充分发挥CPU对主存的利用率（DMA控制并使用主存）

（2）周期挪用（或周期窃取)

DMA申请建立主线的使用权（此时有三种情况：此时CPU不访存或者CPU正在访存或者CPU与DMA同时请求访存，此时CPU将总线控制权让给DMA）
CPU可以利用间隙使用主存，主存工作时间充分

采用DMA方式传递数据时，每传送一个数据就要占用一个 ==存储周期==  。

A、指令周期

（3）DMA与CPU交替访问

CPU工作周期划为两部分，C^1^专供DMA访存，C^2^专供CPU访存

不需要申请建立和归还总线的使用权

****

3.DMA接口功能：

1. 向CPU申请DMA传送
2. 处理总线控制权的转交
3. 管理系统总线、控制数据传送
4. 确定数据传送的首地址和长度，修正传送过程中的数据地址和长度
5. DMA传送结束时，给出操作完成信号

****

4.DMA接口结构：

AR地址寄存器：存放CPU要传输数据的位置，每传输一个地址位+1

WC计数器：值为-n，每传输一个数据+1，到0传输完毕

BR数据缓冲器：外部数据暂存区

DAR设备地址寄存器：供设备选择电路使用

****

5.DMA控制逻辑

设备向DMA控制逻辑发出DREQ指令，后者返还DACK命令，并向CPU注册呢发出HRQ指令，请求主线使用，成功返还HLDA。当WC归0发出溢出信号到中断机构，发出中断请求。

DMA传送过程：预处理（通知DMA控制逻辑传送方向入或出，告知设备地址DAR，主存地址AR传送字数WC），数据传送（CPU继续执行数据输入输出之后的其他指令，DMA完成一批数据传送）、后处理（中断服务程序，DMA结束处理，这里包括校验送入主存数准确性，判断是否要再使用DMA以及测试传送过程是否正确）

****

6.DMA接口与系统连接方式

（1）有公共请求线的DMA请求

所有DMA接口有一条总线连到CPU，CPU一条DMA响应线到所有接口，优先级高的先处理

（2）独立的DMA接口

每一个DMA接口独立与CPU连接两条请求和响应线

****

7.DMA方式与程序中断方式比较：

|                   | 中断方式     | DMA方式      |
| ----------------- | ------------ | ------------ |
| （1）数据传送     | 程序         | 硬件         |
| （2）响应时间     | 指令执行结束 | 存取周期结束 |
| （3）处理异常情况 | 能           | 不能         |
| （4）中断请求     | 传送数据     | 后处理       |
| （5）优先级       | 低           | 高           |

8.DMA接口类型

（1）选择型：在物理上连接多个设备，在逻辑上只允许连接一个设备——设备都连接在一起，但是用一条选择线连到DMA接口上。适用于数据传输速率高的设备

(2)多路型：在物理上连接多个设备，在逻辑上允许连接多个设备同时工作

多个设备在多个子通道（涵盖字节缓冲，状态控制和固定地址）中，经过数据缓冲到CPU

（3）多路型DMA接口工作原理

每个设备来回接用DMA端口，一个结束后就会为另一个设备服务

## 第五章数字（cpu铺垫）

### 无符号数有符号数——机器数，真值转化

真值：带符号的数，机器数：符号数字化的数

计算机分为两类，小数点在数据位之前和在数据位之后

#### 原码表示法

定义：

==整数==

​             0,x       [2^n^>x>=0]

x原=

​            2^n^-x     [0>=x>-2^n^]



x为真值，n为整数的位数，如[x]~原~=0，1110（用==逗号==隔开符号位和数值部分）

==小数==

定义：

​             x       [1>x>=0]

x原=

​            1-x     [0>=x>-1]



x为真值，如[x]~原~=0.1110（用==小数点==隔开符号位和数值部分）

原码特点：简单直观，可是加法时会出现问题

#### 补码表示法

补的概念（时钟逆时针顺时针——减加转化6-3=6+9  12小时一转，称+9是-3以12为模的补数）

因此可以给一个负数加上模，得到负数的补数——正数和负数互为补数，绝对值之和就是模数

正数补数就是其本身

==整数==

定义：

​             0,x       [2^n^>x>=0]

x原=

​            2^n+1^+x     [0>x>=-2^n^]（mod2^n+1^）



与上相同，要用==逗号==隔开符号位和数值部分

==小数==

定义：

​             x       [1>x>=0]

x原=

​            2+x     [0>x>=-1]（mod 2）



与上相同，要用==小数点==隔开符号位和数值部分

**<u>真正求补码方法：反码+1（不带符号位）</u>**

原理：n位二进制数（负），加n+1满数（-1011——》加11111）再加1，加上这个n位二进制数（结果带上符号位）

补码——》原码 ：-1后取反（最后记得加负号）

[补码详细原理使用](https://blog.csdn.net/qq_45472866/article/details/114779170)

#### 反码表示法

定义：

注意！！正数反码是其本身

==整数==

​             0,x       [2^n^>x>=0]

x原=

​            （2^n+1^-1）+x     [0>=x>-2^n^]（mod2^n+1^-1）

==小数==

​             x       [1>x>=0]

x原=

​            （2-2^-n^）+x     [0>=x>-1]（mod2-2^-n^）

数值部分每位取反，再加上符号位，用符号隔开，整数是逗号，小数是小数点

****

小结：

最高位为符号位，书写上用“,”（整数)  或“.”(小数）将数值部分和符号位隔开

对于正数，原码=补码=反码

对于负数，符号位为1，其数值部分原码除符号位外每位取反末位加1——》补码，原码除符号位外每位取反——》反码

**<u>求一个数的相反数的补码只需要将原数连同符号位在内，每位取反，末位加1即可（无论原数正负）</u>**

#### 移码表示法

原因：补码很难直接判断真值大小

 [x]~移~=2^n^+x  (2^n^>x>=-2^n^)

补码与移码数值部分完全相同，但是符号位取反

特点：

- x=0时无论正负，补码都是相等的
- 最小真值的移码都是0

- 用移码表示浮点数的阶码能方便地判断浮点数的阶码大小

### 定点表示浮点表示

定点表示

| 定点机 |      小数定点机       |     整数定点机      |
| :----: | :-------------------: | :-----------------: |
|  原码  | -(1-2^-n^)~+(1-2^-n^) | -(2^n^-1)~+(2^n^-1) |
|  补码  |     -1~+(1-2^-n^)     |   -2^n^~+(2^n^-1)   |
|  反码  | -(1-2^-n^)~+(1-2^-n^) | -(2^n^-1)~+(2^n^-1) |

浮点表示

为什么要引入浮点数表示
编程困难，程序员要调节小数点的位置;   数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长;      存储单元利用率低

N=S×r^j^——浮点数的一般形式

S尾数（小数可正可负）    j阶码 （整数可正可负）     r尾数的基数

浮点数表示形式

![image-20240129144251378](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129144251378.png)

浮点数表示范围

![image-20240129151242956](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129151242956.png)

浮点数规格化形式——尽可能保证数据精度
r =2          尾数最高位为1
r =4          尾数最高2位不全为0
r =8		  尾数最高3位不全为0
基数不同，浮点数的规格化形式不同
方法：

r =2     左规        尾数左移1位，阶码减1
右规    尾数右移1位，阶码加1
r = 4    左规        尾数左移2位，阶码减1
右规    尾数右移2位，阶码加1
r =8      左规        尾数左移3位，阶码减1
右规      尾数右移3位，阶码加1

基数r越大，可表示的浮点数的范围越大。基数r越大，浮点数的精度降低

![image-20240129154304345](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129154304345.png)

这种相除先转化为二级制形式，128——》10000000就有2^-111^，写出19二进制形式，移动小数点就可以得到结果的二进制形式，定点表示补足剩余数值位即可。浮点规格化会先规格化结果，再补足数据位；然后按照公式写出浮点数表示的形式即可。

![image-20240129155740252](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129155740252.png)



![image-20240129163201104](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129163201104.png)

机器零：

当浮点数尾数为0时，不论其阶码为何值按机器零处理
当浮点数阶码等于或小于它所表示的最小数时，不论尾数为何值，按机器零处理

有利于机器中“判0”电路的实现

![image-20240129165916944](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129165916944.png)

### 定点运算

#### 移位运算

机器用语，数相对于小数点移动，小数点不动——左移绝对值扩大，右移绝对值缩小。在计算机中移位与加减配合可以实现乘除运算

算术移位规则

![image-20240129173250383](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129173250383.png)

![image-20240129221833008](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129221833008.png)

⬅丢1       出错					出错				正确				正确

➡丢1	 影响精度			影响精度		影响精度			正确

左边为符号位，右边为数据部分，利用正数符号位为0，负数符号位为1实现简化逻辑

****

加法：整数——两个数各自的补码相加就是两个数和的**<u>补码</u>**，mod为2^n+1^，小数——两个数各自的补码相加就是两个数和的**<u>补码</u>**，mod为2^n^

减法：减数取反然后相加即可，相加过程以及mod同上

注意加减法过程中，要连同符号位一起相加，最高位（符号位）进位自动舍弃

补码运算容易发生溢出现象，因此要进行溢出判断

(1)一位符号位判溢出
参加操作的两个数（减法时即为被减数和“求补”以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出

硬件实现：

最高有效位的进位 ==异或== 符号位的进位 = 1，此时就会发生溢出

（2）两位符号位判断溢出

​			x	1>x>=0/4+x

[x]~补`~ =     

​			4+x   0>x>=-1(mod 4)

按上面的加减法进行即可

结果的双符号位相同        未溢出
结果的双符号位不同        溢出

实际就是第一个符号位为实际的符号位，第二个符号位存进位

![image-20240129222315322](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129222315322.png)

X寄存器保存加数或减数

求补判断X中是否为负或X为减数，进行求补运算

这里如果要求补只需要一个非门，然后全加器进位C保持高电平即可实现求补数

****

#### 乘法运算

根据乘法笔算的分解，可以看出乘法运算可以用加法和移位操作实现，（平常向左移位也可以优化为向右移位同时改变相乘顺序）n位二进制数，加n位，移n位

由乘数的末位决定被乘数是否与原部分积相加，然后——》右移1位形成新的部分积，同时乘数——》1位(末位移丢)，空出高位存放部分积的低位。

[参考](https://wenku.baidu.com/view/ebe8f3bca2116c175f0e7cd184254b35eefd1a32.html?_wkts_=1706883444786)

被乘数只与部分积的高位相加

因此可以推出硬件部分：3个寄存器（1个一直保持被乘数）两个具有移位功能，1个全加器

****

原码乘法：乘积的符号位单独处理（异或求），数值部分为绝对值相乘

原码一位乘递推公式

z~0~=0,   z~1~=2^-1^(y~n~x^*^+z~0~)     z~1~=2^-1^(y~n-1~x^*^+z~1~)   . .. . .  ..     z~1~=2^-1^(y~1~x^*^+z~n-1~) 

特点：绝对值运算，用移位的次数判断乘法是否结束，逻辑移位

 ![image-20240129225632883](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240129225632883.png)

A寄存器中n+1位，最高位用来保存进位，保存部分积，并将其向Q乘数寄存器中传递

被乘数保存在X寄存器中，保持不变

Q乘数寄存器，进行移位和加控制，与计数器C对移位次数进行计数，移位n次后说明乘计算结束。

S符号位，将两个乘数符号位进行异或计算。

简化逻辑：当乘数最后一位n不是0时，控制门才会打开放进X中的被乘数，随后在加法器中Q被积数与新被积数相加，送到A中，如果乘数最后一位n是0，那么控制门不打开，直接移位，因此是记录移位的次数来判断是否乘法结束，而不是乘法进行的次数

#### 除法运算

二进制除法算到同除数被除数同一位即可

机器除法：符号位异或形成，被除数绝对值减去除数绝对值大于1就上商1，反之上商0。每一位的余数部分同笔算不同，刚好相反，机器除法余数左移一位低位补0减去除数（使得余数不会一直右移使得字长变大，多占用空间）。因此使用1位加法器，且在寄存器末尾上商

原码除法

符号位单独处理异或实现，数值部分绝对值相除

约定：小数定点除法：被除数要小于除数

​			整数定点除法：被除数要大于除数

被除数不等于0，除数不能为0

![](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20240130100136.png)

操作就是余数为正，上商1，反之上商0并恢复余数

特点：第一次上商判断溢出（必须为0）

​          上商n+1次，移位n次

（2）不恢复余数法(y^*^为绝对值)

上商1     2R~i~-y^*^

上商0     2R~i~+y^*^

加减交替

![image-20240130102413987](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130102413987.png)

特点：上商n+1次，移位n次，加n+1次

第一次上商判断溢出（必须为0）

用移位的次数判断除法是否结束

![image-20240130105652324](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130105652324.png)

A寄存器保存被除数和余数

X寄存器保存除数

Q寄存器保存商，商的最低位控制移位和加减

计数器计数移位次数或者加次数判断除法是否完成

加法器结果余数保存在A中，同时据此判断上商0还是1到Q中

### 浮点运算

#### 加减运算

x=S~x~×2^j~x~^       y=S~y~×2^j~y~^

1.对阶

求阶差

​					0    说明已对齐

▲j=j~x~-j~y~=    >0   j~x~>j~y~    x向y看齐 S~x~左移一位，j~x~-1或==y向x看齐S~y~右移一位，j~y~+1==

​				    <0   j~x~<j~y~    ==x向y看齐 S~x~右移一位，j~x~+1==或y向x看齐S~y~左移一位，j~y~-1       

对阶原则：小阶向大阶对齐

以下是双符号位最简单直接取舍的例子

![image-20240130114202477](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130114202477.png)

****

规格化数定义

r=2     0.5=<|S|<1

判断

| S>0  | 规格化形式 | S<0  | 规格化形式 |
| :--: | :--------: | :--: | :--------: |
| 真值 | 0.1XXX……X  | 真值 | -0.1XXX……X |
| 原码 | 0.1XXX……X  | 原码 | 1.1XXX……X  |
| 补码 | 0.1XXX……X  | 补码 | 1.0XXX……X  |
| 反码 | 0.1XXX……X  | 反码 | 1.0XXX……X  |

原码    不论正数、负数，第一数位为1

补码    符号位和数值位第一数位不同

特例：![image-20240130145903844](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130145903844.png)

规格化方法：

通过对将原码或补码表示的尾数进行左移或右移（按照上图的规则），变成符合规格的形式（上面表格里的形式）即可。

对于尾数用补码表示的双符号位：

​      形式									操作说明
00.1XXXX								规范形式
11.0XXXX								规范形式
00.0XXXX						非规范形式，左移补0
11.1XXXX						非规范形式，左移补0
01.XXXX				有假溢出，右移补0，变成00.1XXXX
10.XXXX				有假溢出，右移补1，变成11.0XXXX
后两行溢出解释：
因为双符号位尾数的符号取决于符号位的最高位，即01.XXXX最高位为0，所以是正数，补码正数右移补0；同理，10.XXXX最高位为1，所以是负数，补码负数右移补1。

舍入：由于对阶和右规，尾数末尾右移，造成尾数过长计算机无法存储，解决这种问题就是舍入

（1）**就近舍入**

- 多余数字是1001，它大于0.5，故最低位进1。

- 多余数字是0111，它小于0.5，则直接舍掉多余数字。

- 多余数字是1000，正好是等于0.5的特殊情况；那么此时最低位为0则舍掉多余位，最低位为1则进位1。

  **注意这里说明的数位都是指二进制数。因为这是尾数，所以在计算这些二进制和0.5的关系的时候，也即转为10进制的时候，我们用每一位的权重乘以2^(-i)然后求和即可。**

（2）恒置1法

恒舍去多余部分，高位进1

（3）0舍1入法

多余部分最高位是1，就进1，反之就进0

![image-20240130154838790](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130154838790.png)

### 算术逻辑单元

ALU电路

注意不是时序逻辑电路，因此一般需要加多个寄存器。

![image-20240130155630437](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130155630437.png)

快速进位链

前置条件：并行加法器

![](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20240130163225.png)

串行进位链

![image-20240130163704557](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130163704557.png)

产生进位时间过长，产生以下改进

并行进位链

![image-20240130164420313](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130164420313.png)

由于连线过多，因此产生如下的改进

![image-20240130164924146](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130164924146.png)

分组思想同时改善空间和时间，但是组数过多时，时间也花费很长，因此产生如下改进

![image-20240130165232809](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130165232809.png)

一个小组只产生低3位的进位和本小组的D，T

一个大组产生多个进位结果

![image-20240130170412027](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130170412027.png)

以此推算，可以得到更多位（32位，64位）进位链的进行过程及需要时间

### 第六章指令系统

指令格式

操作码，地址码，寻址方式

指令字长

固定字长，可变字长

#### 机器指令

操作码字段（反映机器做什么操作），地址码字段

(1)长度固定
用于指令字长较长的情况，RISC，如IBM 370  操作码8位

(2)长度可变   x86
操作码分散在指令字的不同字段中

(3)扩展操作码技术

操作码的位数随地址数减少而增加

![image-20240130174344074](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130174344074.png)

经常出现的高频指令用短操作码表示，不经常出现的指令用长操作码表示

****

地址码

![Collage_20240130_175856](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/Collage_20240130_175856.jpg)

ACC累加器寄存器，不在内存中，存放操作数

零地址适用于两个数据都在ACC寄存器中，或者是进行全加器运算（数据都在全加器中，因此不需要访存）

****

指令字长

由操作码的长度，操作数地址的长度，操作数地址的个数决定

1.指令字长固定

​    指令字长=存储字长

2.指令字长可变

​     按字节的倍数变化

****

小结：

当用一些硬件资源代替指令字中的地址码字段后

- 可扩大指令的寻址范围

- 可缩短指令字长

- 可减少访存次数

当指令的地址字段为寄存器时

三地址 OP R~1~，R~2~，R~3~

二地址OP R~1~，R~2~

一地址OP R~3~

可缩短指令字长

#### 操作数类型和种类

1.类型

地址           无符号整数

数字            定点数、浮点数、十进制数

字符            ASCII

逻辑数         逻辑运算

 2.数据在存储器中的存放方式

例   1 2 3 4 5 6 7 8 H存放方式

0  12H  34H  56H  78H

4   

8   

字地址为高字节地址               

0  78H  56H  34H  12H

4   

8   

字地址为低字节地址               

字节编址，数据在存储器中的存储方式（存储字长64位，机器字长32位）

(1)从任意位置开始存储

优点：不浪费存储资源

缺点：除了访问一个字节外，访问其他类型的数据都有可能花费两个存储周期的时间。读写控制比较复杂

(2)从一个存储字的起始位置开始访问

优点:无论访问何种类型的数据，在一个周期均可完成，读写控制简单。
缺点:浪费了宝贵的存储资源

(3)边界对准方式——**从地址的整数倍位置开始访问**

数据存放的起始地址是数据长度（按照编址单位进行计算）的整数倍

是前两方案的折中

3.操作类型

(1)数据传送

源         寄存器      寄存器     存储器      存储器    

目的     寄存器      存储器      寄存器      存储器    

例如      MOVE      STORE      LOAD       MOVE

​                               MOVE       MOVE

​                               PUSH         POP

置“1”，清“0”

(2)算术逻辑操作

加减乘除，增1减1，求补浮点运算

与或非，异或，位操作，位测试，位清除，位求反

(3)移位操作

算术移位（不带符号位）逻辑移位（带符号为）循环移位（带进位和不带进位）

(4)转移

a.无条件转移

b.条件转移

结果为零转     （Z=1）JZ

结果溢出转        (O=1)  JO

结果有进位转     (C=1)  JC

跳过一条指令 SKP

c.调用和返回

比如主函数里含有多个子函数，执行主函数遇到子函数，跳转到子函数中执行，执行结束后返回主函数继续执行，再遇到子函数重复上述步骤，直到结束

d.陷阱与陷阱指令

意外事故的中断

- 一般不提供给用户直接使用

  在出现事故时，由CPU自动产生并执行（隐指令）

- 设置供用户使用的陷阱指令

​	如    8086     INT    TYPE     软中断

​	提供给用户使用的陷阱指令，完成系统调用

(5)输入输出

入       端口内容——》CPU寄存器

如      IN  AX，n             IN  AX，DX

出       CPU寄存器——》端口中的内容

如      OUT   n，AX         OUT  DX，AX

#### 寻址方式

确定本条指令的操作数地址。下一条要执行指令的指令地址

寻址方式分为指令寻址和数据寻址

指令寻址

顺序   PC + 1（指令长度）——》PC

跳跃   由转移指令指出，跳转到转移指令指定的地址

数据寻址

| 操作码 | 寻址特性 | 形似地址A |
| :----: | :------: | :-------: |

形式地址       指令字中的地址
有效地址       操作数的真实地址
约定     指令字长=存储字长=机器字长

1.立即寻址

形式地址A就是操作数

|  OP  | #（立即寻址特性） | A（立即数） |
| :--: | :---------------: | :---------: |

指令执行阶段不访存

A的位数限制立即数的范围

2.直接寻址

EA = A 有效地址由形式地址直接给出

![image-20240130201658046](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130201658046.png)

3.隐含寻址

操作数地址隐含在操作码中

![image-20240130202449871](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130202449871.png)

4.间接寻址

![image-20240130203109905](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130203109905.png)

类似转移部分的跳转和返回（即主函数子函数的执行过程），这里就是主程序执行过程中，调用子程序便转移到子程序，执行子程序直到结束会有一条JMP指令回到主程序。

5.寄存器直接寻址

![image-20240130204225088](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130204225088.png)

6.寄存器间接寻址

![image-20240130204336491](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130204336491.png)

7.基址寻址

![image-20240130204914059](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130204914059.png)

![image-20240130205218024](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130205218024.png)

8.变址寻址

与基址寻址(1)极其相似，只不过将专用寄存器BR换为变址寄存器IX（当然，通用寄存器也可以当作变址寄存器）

- 可扩大寻址范围
- IX的内容由用户给定
- 在程序的执行过程中IX内容可变，形式地址A不
- 便于处理数组问题

9.相对寻址

![image-20240130212541919](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130212541919.png)

更利于实现循环，因为指令随程序在存储空间的位置不同而不同，但是每条指令之间的相对位移量不变，因此更能适应程序变动

10.堆栈寻址

![image-20240130213905266](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240130213905266.png)

SP修改与主存编址方法有关

①按字编址
进栈(SP)-1 → SP   出栈(SP)+1 → SP
②按字节编址
存储字长16位   进栈(SP)-2 → SP  出栈(SP) ＋2 → SP
存储字长32位    进栈(SP)-4→ Sp   出栈(SP)＋4→SP

****

直接寻址，变址寻址示例

数据块首地址D，N个数

直接：将数据首地址D放入ACC中，随后累加到结束，然后除以个数即可

变址：首先会进行清空操作，清空ACC和X；然后X移动到D地址，逐渐增加变址寄存器中地址，然后与数个数N对比，不相等就回传回去继续加直到相等。这样指令数会比直接寻址少很多

****

#### 指令格式

一、设计指令格式时应考虑的各种因素

1.指令系统的兼容性
2.其他因素
操作类型      包括指令个数及操作的难易程度
数据类型       确定哪些数据类型可参与操作
指令格式       指令字长是否固定        操作码位数、是否采用扩展操作码技术         地址码位数、地址个数、寻址方式类型
寻址方式      指令寻址、操作数寻址
寄存器个数      寄存器的多少直接影响指令的执行时间

****

RISC技术

精简指令集计算机

与之相对的就是CISC复杂指令集计算机

80-20规律

典型程序中80%的语句仅仅使用处理机中20%的指令。执行频率高的简单指令，因复杂指令的存在，执行速度无法提高

由于这些问题，用20%的简单指令组合不常用的80%的指令功能——RISC技术

RISC特征：

- 选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合

- 指令长度固定、指令格式种类少、寻址方式少

- 只有LOAD / STORE 指令访存

- CPU中有多个通用寄存器

- 采用流水技术  一个时钟周期内完成一条指令

- 采用组合逻辑实现控制器

CISC特征：

- 系统指令复杂庞大，各种指令使用频度相差大

- 指令长度不固定、指令格式种类多、寻址方式多
- 访存指令不受限制

- CPU中设有专用寄存器

- 大多数指令需要多个时钟周期执行完毕

- 采用微程序控制器

比较：1.RISC更能充分利用VLSI芯片的面积

2.RISC更能提高计算机运算速度，指令数、指令格式、寻址方式少，通用寄存器多，采用组合逻辑，便于实现指令流水
3.RISC便于设计，可降低成本，提高可靠性

4.RISC不易实现指令系统兼容

## 第七章CPU结构和功能

### CPU功能和结构

1.控制器功能

取指令；分析指令；执行指令，发出各种操作命令；控制程序输入及结果的输出；总线管理；处理异常情况和特殊请求

2.运算器功能

实现算术运算和逻辑运算

由以上可得到CPU功能需求：**指令控制，操作控制，时间控制，处理中断，数据加工**

cpu结构框图

注意地址总线对于CPU来说是单向的，因为CPU发出到内存寻址到数据总线传输

![image-20240131110238978](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240131110238978.png)

CPU寄存器

![Collage_20240131_111243](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/Collage_20240131_111243.jpg)

控制单元CU和中断系统

CU  产生全部指令的微操作命令序列

组合逻辑设计   硬连线逻辑      微程序设计     存储逻辑

RISC  采用   硬连线逻辑——速度快

### 指令周期

**定义**：取出并执行一条指令所需的全部时间
完成一条指令：取指、分析——取指周期，执行（取操作数，执行，结果返回）——执行周期

**每条指令的指令周期不同**

**具有间接寻址的指令周期**：在取值周期和执行周期中间会有一个间址周期

**带有中断周期的指令周期**：指令中含有中断指令，在取值周期和执行周期中间会有一个间址周期，执行周期后会有中断周期

**指令周期流程**：取指周期——》检查是否有间址，有就转到间址周期，间址周期完成之后也到执行周期；没有就到执行周期——》执行周期——》检查有没有中断程序——》有转移到中断程序，完成后也重新转移到取指周期，没有直接转到取值周期

**CPU工作周期标志**（4个工作周期）：取指令——取指周期，取地址——间址周期，存取操作数或结果——执行周期，存程序断点——中断周期

采用4个D触发器标记当前指令的执行阶段

指令周期数据流（MAR地址寄存器，MDR数据寄存器，IR指令寄存器，CU控制器核心部件控制单元）

1.取指周期数据流

写操作：PC将指令给MAR，随后传递到地址总线，地址总线传递到存储器

读操作：CU将信息给控制总线，控制总线随后将信息给存储器，存储器将数据读出到数据总线，数据总线给到CPU中的MDR，MDR最后到给IR，完成读操作。

2.间址周期数据流

MDR将信息传给MAR取出操作数的地址位传递到地址总线，传递到存储器；同时CPU将信号从CU传递到控制总线，将信号传到存储器，存储器读出这条指令需要的地址位传递到数据总线，然后传到MDR。

3.执行周期数据流

不同指令的执行周期数据流不同

4.中断周期数据流

CU将操作地址传给MAR，MAR传给地址总线再传到存储器，同时CU将指令传给控制总线再到存储器，有了指令和操作地址，存储器内就可以进行断点保存（断点——中断指令后下一条指令的地址（PC值），断点保存属于写操作）因此还需要下一条指令的地址（PC信息的传递），CU控制单元算出下一个指令地址，传给PC，PC将下一条地址传给MDR，然后给到数据总线到达存储器；然后就可以进行断点保存。

### 指令流水

1.提高访存速度
高速芯片      Cache       多体并行
2.提高I/O和主机之间的传送速度
中断       DMA      通道     IO处理机      多总线

补充：通道方式：特殊的IO处理机，与CPU共享内存。CPU把指令传给通道，由通道对内存进行操作，CPU可继续其他工作。I/O通道方式是DMA方式的发展，它可以进一步 减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关控制和管理为单位的干预。同时，又可以实现CPU、通道和I/0 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。

3．提高运算器速度
高速芯片         改进算法       快速进位链

提高整机处理能力高速器件
改进系统结构，开发系统的并行性

****

系统并行性

并行即并发（两个或两个以上事件在<u>**同一时间段**</u>发生）和同时（两个或两个以上事件在**<u>同一时刻</u>**发生）即时间上互相重叠

等级：过程级（程序、进程)粗粒度——软件实现，指令级(指令之间)(指令内部)细粒度——硬件实现

指令流水原理：

CPU功能很多，有很多不同功能的功能部件，因此可以将执行周期分为好几个阶段，同时进行很多程序（即多条指令集进行），使得CPU每个功能部件都在运作。

![image-20240131155302941](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240131155302941.png)

影响指令流水效率加倍的因素（解决方法参考体系结构）：

(1)执行时间>取指时间
取指令部件——》指令部件缓冲区——》执行指令部件

(2)条件转移指令对指令流水的影响

必须等上条指令执行结束，才能确定下条指令的地址造成时间损失

影响指令流水线性能的因素（解决方法参考体系结构）：

1．结构相关不同指令争用同一功能部件产生资源冲突

解决方法：停顿（要用到同一个功能部件首先执行下一条指令集）。指令存储器和数据存储器分开。指令预取技术（适用于访存周期短的情况)

2.数据相关

不同指令因重叠操作，可能改变操作数的读/写访问顺序（然而实际上这些指令改变顺序就会出错）

- 写后读相关（RAW)

先要SUB  R~1~，R~2~，R~3~;   (R~2~)-(R~3~)→R~1~

才能ADD R~4~，R~5~，R~1~;    (R~5~)＋(R~1~)→R~4~

- 读后写相关(WAR)

先要读取STA M，R~2~;  (R~2~）→M存储单元

才能ADD R~2~，R~4~，R~5~;    (R~4~)+(R~5~)→R~2~

- 写后写相关(WAW)

先要MUL  R~3~，R~2~，R~1~;     (R~2~）x   (R~1~)→R~3~

才能SUB   R~3~，R~4~，R~5~；(R~4~)-(R~5~)→R~3~

解决方法：后推法。采用旁路技术

3.控制相关

由转移指令引起

比如条件转移指令，在未执行前，不知道是否满足条件进行跳转，导致其他流水线正常顺序进行，可是发生跳转后，其他流水线工作因此全部作废。造成损失。

****

吞吐率：单位时间内流水线所完成指令或输出结果的数量，设m段的流水线各段时间为△t

最大吞吐率：T~pmax~=1/△t

实际吞吐率：（连续处理n条指令的吞吐率）T~p~=n/[m△t+（n-1）△t]

2.加速比S~p~

m段的**流水线的速度**与等功能的**非流水线的速度**之比设流水线各段时间为△t
完成n条指令在m段流水线上共需T=m×△t+(n-1)△t

完成n条指令在等效的非流水线上共需T`=nm×△t

S~p~=T/T`=nm/（n+m-1）

3.效率

流水线中各功能段的利用率

由于流水线有建立时间和排空时间
因此各功能段的设备不可能一直处于工作状态
效率= 流水线各段处于工作时间的时空区/流水线中各段总的时空区

****

流水线多发技术

1.超标量技术（多条流水线）

每个时钟周期内可并发多条独立指令——配置多个功能部件
不能调整指令的执行顺序——通过编译优化技术，把可并行执行的指令搭配起来

2.超流水线技术（流水线速度是原来的3倍）

超流水就是在一个时钟周期内，执行多条独立的指令的同一操作

在一个时钟周期内再分段（3段)
在一个时钟周期内一个功能部件使用多次（3次)

不同指令处于同一流水段中，相互之间信号不会叠加，就是流水段内细分的3个指令之间存在相关，产生的数据不能互相使用，因为没有锁存器cache进行缓冲

不能调整指令的执行顺序，靠编译程序解决优化问题

3.超长指令字技术

由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条
具有多个操作码字段的超长指令字（可达几百位)

流水线结构

指令流水线结构：完成一条指令分6段，每段需一个时钟周期即——取指令部件——》指令译码部件——》地址形成部件——》取操作数部件——》操作执行部件——》回写结构部件

若流水线不出现断流：1个时钟周期出1结果
不采用流水技术：6个时钟周期出1结果

理想情况下，6级流水的速度是不采用流水技术的6倍，需要锁存器对流水线每个阶段结果的锁存

运算流水线：完成浮点加减运算，可分对阶、尾数求和、规格化三段

对阶功能部件——》锁存器（第一段）——》尾数加部件——》锁存器（第二段）——》规格化部件——》锁存器（第三段）

因此有分段原则 每段操作时间尽量一致

### 中断系统

1.引起中断的因素：

(1)人为设置的中断，如转管指令

(2)程序性事故﹐溢出、操作码不能识别、除法非法

(3)硬件故障

(4) I/O设备

(5)外部事件,如：用键盘中断现行程序

2.中断系统需解决的问题

(1)各中断源如何向CPU提出请求?

中断请求标记 INTR

一个请求源就是一个INTR中断请求标记触发器

多个INTR组成中断请求标记寄存器

INTR分布：INTR分散在各个中断源的接口电路中或INTR集中在 CPU的中断系统内

(2)各中断源同时提出请求怎么办?

中断判优逻辑

a.硬件实现（排队器）

分散在各个中断源的接口电路中——链式排队器

集中在CPU内

![image-20240131164829410](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240131164829410.png)

优先级按降序排列

b.软件实现（程序查询）

按优先级向下查询有无中断情求，有就跳转，没有就继续向下查询

(3) CPU什么条件、什么时间、以什么方式响应中断?

响应中断的条件：允许中断触发器EINT= 1

响应中断的时间

如果指令执行时中断，破坏执行状态，需要现场保护的数据更多，而且恢复现场后还需要重新执行指令，浪费之前指令的执行时间。因此一般在指令结束后由CPU发送查询信号到中断触发器，再送到排队器等待中断

a.保护程序断点
断点存于特定地址（0号地址）内断点进栈

b.寻找服务程序入口地址

向量地址→PC(硬件向量法)

中断识别程序入口地址 M→PC(软件查询法)

c.硬件关中断

![image-20240131170729329](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240131170729329.png)

两个R -S触发器，INT中断标记，EINT允许中断
它里面是一个或非门，只有当两个线路都为0时，s输出才为1。当排队器有一条线为高电平，经过或门，输出为高电平1；EINT此时为高电平1；所以与非门输出为低电平0，此时INT置为1，经过非门后，才可以将EINT置为0

(4)如何保护现场?

断点——中断隐指令完成
寄存器内容——中断服务程序完成

恢复现场——中断服务程序完成

中断服务程序涵盖保护现场（PUSH），其他服务程序（视不同请求源而定），恢复现场（POP），中断返回（IRET）

(5)如何寻找入口地址？

a. 硬件向量法

排队器输出到向量地址形成部件，生成中断向量地址

b.软件查询法

中断识别程序（其中含有入口地址M）进行识别

(6)如何恢复现场，如何返回?

 ![image-20240131174512760](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240131174512760.png)

(7)处理中断的过程中又出现新的中断怎么办?

多重中断：出现更紧急的中断先处理更紧急的随后返回原状态处理之前未处理的中断

实现多重中断条件

(1)提前设置开中断指令
(2)优先级别高的中断源有权中断优先级别低的中断源

中断屏蔽技术

![image-20240131172804812](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240131172804812.png)

屏蔽字

这就是指优先级，哪个中断源在执行，其后面的（包括自己）都是1，表示不能提出中断请求；其前面的都是0，表示可以提出中断请求，打断中断

屏蔽技术可改变处理优先级

![Collage_20240131_173832](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/Collage_20240131_173832.jpg)

新屏蔽字设置

保护现场——》置屏蔽字——》开中断——》中断服务——》关中断——》恢复现场——》恢复屏蔽字——》开中断——》中断扳回

## 第八章控制单元

微操作命令：在指令解释过程中由控制单元发出的指令

完成一条指令需要分4个周期：取指周期，间址周期，执行周期，中断周期

1.非访存指令

清0，取反，算术右移，循环左移，停机指示

2.访存指令

加法指令，存数指令，取数指令

3.转移指令

无条件转，条件转移

功能：

(1)输入信号

CU受时钟控制，一个时钟脉冲，发一个操作命令或一组需同时执行的操作命令

指令寄存器：  OP（IR）——》CU

控制信号与操作码有关

标志：CU受标志控制

外来信号：INTR中断请求，HRQ总线请求

(2)输出信号

CPU内的各种信号

加减乘除算术运算，与或逻辑运算，移位等等

(3)送至控制总线的信号

MREQ——访存控制信号

IO/M——访IO/存储器控制信号

RD——读命令

WR——写信号

INTA——中断响应信号

HLDA——总线响应信号

控制信号举例：

不采用CPU内部总线的方式（cpu内部部件分散）

![image-20240201103301780](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240201103301780.png)

MAR地址寄存器，取指（或间址）都会由PC传递到MAR从存储器取出传回MDR才算指令取出

随后按命令步骤执行即可

采用CPU内部总线的方式

![image-20240201104652899](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240201104652899.png)

多级时序系统

1.机器周期
(1)机器周期的概念
所有指令执行过程中的一个基准时间

(2)确定机器周期需考虑的因素
每条指令的执行步骤
每一步骤所需的时间

(3)基准时间的确定
以完成最复杂指令功能的时间为准

以访问一次存储器的时间为基准

若指令字长=存储字长    那么取指周期=机器周期

2.时钟周期

一个机器周期内可完成若干个微操作
每个微操作需一定的时间

可将一个机器周期分成若干个时间相等的时间段（节拍、状态、时钟周期)

因此时钟周期是控制计算机操作的最小单位时间

用时钟周期控制产生一个或几个微操作命令

3.多级时序系统

机器周期、节拍（状态）组成多级时序系统，一个指令周期包含若干个机器周期
一个机器周期包含若干个时钟周期

4.机器速度与机器主频的关系

机器的主频f越快机器的速度也越快。在机器周期所含时钟周期数相同的前提下，两机平均指令执行速度之比等于两机主频之比

但是机器速度不仅与主频有关，还与机器周期中所含时钟周期（主频的倒数）数以及指令周期中所含的机器周期数有关

控制方式

产生不同微操作命令序列所用的时序控制方式

1.同步控制方式
任一微操作均由统一基准时标的时序信号控制

(1)采用定长的机器周期
以最长的微操作序列和最复杂的微操作作为标准

(2)采用不定长的机器周期
机器周期内节拍数不等即遇到复杂指令会将周期延长

(3)采用中央控制和局部控制相结合的方法

![image-20240201111028726](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240201111028726.png)

2.异步控制方式

无基准时标信号
无固定的周期节拍和严格的时钟同步，采用应答方式

3.联合控制方式

同步与异步相结合

4.人工控制方式

(1) Reset

(2)连续和单条指令执行转换开关

(3)符合停机开关

## 第九章控制单元设计

### 组合逻辑控制单元

CU外特性

![image-20240201112009532](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240201112009532.png)

节拍信号就是一个完整的时钟周期，操作码译码就是经过一个译码器

微操作节拍安排：采用同步控制方式，一个机器周期内有3个节拍（时钟周期），CPU内采用非总线方式

操作时序安排原则：

原则一：微操作的先后顺序不得随意更改
原则二：被控对象不同的微操作，尽量安排在一个节拍内完成
原则三：占用时间较短的微操作，尽量安排在一个节拍内完成并允许有先后顺序

#### 取指周期微操作的节拍安排

T0  PC——》MAR，同时发读命令——原则2

T1   M（MAR）——》MDR   PC+1——原则2

T2   MDR——》IR    OP（IR）——》ID——原则3

#### 间址周期微操作的节拍安排

T0   Ad（IR）——》MAR，同时发读命令

T1   M（MAR）——》MDR

T2   MDR——》Ad（IR）

#### 执行周期微操作的节拍安排

1.零地址指令

ACC清0：T2时置0

ACC按位取反：T2时置反

右移操作：T2时利用移位寄存器进行（循环右移同理）

停机：T2时发出信号

2.地址访存操作

累加X与ACC（ADD X）

T0 AD（IR）——》MAR    CU——》R     T0段IR/MDR将操作数地址送入MAR上传地址总线，CU通过控制总线向存储器发出读命令

T1 M（MAR）——》MDR       T1段存储器接收地址数据，将读出的操作数通过数据总线传入MDR

T2  ( AC )+(MDR ) ——》AC         T2段CU发出一系列控制命令，将MDR和ACC的数值输入到ALU，并发出加法指令，将结果保存至ACC

保存ACC结果到指定地址（STA X）

T0      Ad (IR )——》MAR   CU——》W
T1       AC——》MDR
T2       MDR ——》M ( MAR )

T0段IR/MDR将写入地址送入MAR上传地址总线，CU通过控制总线向存储器发出写命令
T1段ACC将数据送入MDR
T2段MDR数据上传数据总线，存储器接收地址和写控制命令，将数据写入到指定的存储单元

读取操作数到ACC（LOD X）

T0      Ad (IR )——》MAR          CU——》R

T1      M ( MAR )——》MDR

T2      MDR——》AC

跳转到给定的指令地址（JMP X）

Ad（IR）——》PC

无论是直接跳转还是间接跳转，执行周期，需要转入的指令地址已经被保存在IR/MDR中

条件跳转（BAN X）

直接验证是否符合条件（一般会给公式）成立就会跳转

中断周期微操作节拍安排
这里是指判定需要开启中断服务时，进行的中断隐指令的微操作节拍安排，包括向“0”地址写入程序断点，硬件关中断，生成中断服务程序入口地址

T0         CU——》MAR      CU ——》w硬件关中断
T1         PC ——》MDR
T2         MDR ——》M ( MAR )     向量地址——》PC

#### 组合逻辑设计步骤

1.列出操作时间表

如下是六大操作步骤组成的微操作命令图

​																										置0操作（clean） 取反操作  加操作    存储操作      读取操作     跳转操作 

![Collage_20240201_152824](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/Collage_20240201_152824.jpg)

如图读取指令的操作是所有指令统一的

CLA清0和COM取反无需间址周期，因而在取指周期T2节拍末直接将EX标识置1，直接进入执行周期

而其它指令，需要间接寻址，因而将IND标识置1，进入间址周期

间接寻址的操作是统一的，间址周期末尾，需要根据取到地址的标识码，决定进入执行周期，还是需要再次间接寻址（这里假设都使用了一次间址）

执行周期操作比较复杂，这里表格没有列全微操作和指令，知道大致思路即可

随后根据上表可以得出每一个微操作达成的多种多样的的条件，由于可能性很多，因此将上表写成逻辑式，用硬连的方法可以得到以下的电路图

![Collage_20240201_152833](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/Collage_20240201_152833.jpg)

特点
>思路清晰，简单明了
>
>庞杂，调试困难，修改困难
>
>速度快（RISC）

### 微程序设计

由于完成一条机器指令需要很多微操作，因此可以将很多微操作当作一个微指令，微指令（含有多位二进制信号，每一位1的信号代表一个微操作命令）存入ROM，这样一条机器指令对应一个微程序——存储逻辑

微指令在ROM中有序保存，读取时有序运行，一个机器周期内的所有微指令构成一个微程序，取指、间址周期微程序可通用，不同的指令需要编写特定的执行周期微程序

![img](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/v2-67d1b6b15b8a83b228977088b457a3f9_720w.webp)

详细工作原理：指令操作码进入微地址形成部件，会产生**执行阶段对应的微程序首地址**，以及是否需要间址周期等其它信息，送入顺序逻辑单元

顺序逻辑单元，根据标志信息（逻辑标志，机器周期标志），时钟频率/节拍，以及微地址形成信号，产生当前需要执行的微指令地址，送入CMAR寄存器

CMAR地址译码后，从控制存储器（ROM）中读出相应的微指令代码，包括操作控制码和下一条指令代码

CU按照操作控制码发出相应的控制信号，下地址送入顺序逻辑中，参与生成下一条微指令地址

取指周期末指令的下地址是终止符，是否进入某个微指令对应的执行周期微程序，或是进入间址周期，需要微地址形成部件给出

而执行周期/中断周期末指令的下地址，均是取指周期的首地址，用于开启下一个指令周期

控制方式：

1.直接编码（直接控制）方式

在微指令的操作控制字段中,每一位代表一个微操作命令

2.字段直接编码方式

将微指令的控制字段分成若干“段”,每段经译码后发出控制信号，显示编码

每个字段中的命令是互斥的缩短了微指令字长，增加了译码时间

3.字段间接编码

隐式编码

4.混合编码
直接编码和字段编码（直接和间接）混合使用

微指令序列地址的形成：

1.微指令的下地址字段指出

2.根据机器指令的操作码形成

3.增量计数器（顺序加1）

4.分支转移

| 操作控制字段 | 转移方式 | 转移地址 |
| :----------: | :------: | :------: |

转移方式——指明判别条件
转移地址——指明转移成功后的去向

5.通过测试网络

6.硬件产生微程序入口地址

第一条微指令地址由专门硬件产生，中断周期由硬件产生中断周期微程序首地址

7.后续微指令地址形成方式原理图

![image-20240201170458401](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/image-20240201170458401.png)

微指令格式：

1.水平型微指令
一次能定义并执行多个并行操作，如直接编码、字段直接编码、字段间接编码。直接和字段混合编码
2.垂直型微指令
类似机器指令操作码的方式，由微操作码字段规定微指令的功能

对比：

(1)水平型微指令比垂直型微指令并行**<u>操作能力强，灵活性强</u>**
(2)水平型微指令执行一条机器指令所要的微指令**<u>数目少，速度快</u>**
(3)水平型微指令**<u>用较短的微程序结构换取较长微指令结构</u>**
(4)水平型微指令与机器指令**<u>差别大</u>**

静态微程序设计和动态微程序设计：
静态﹒微程序无须改变，采用 ROM
动态    通过改变微指令和微程序改变机器指令，有利于仿真，采用EPROM

毫微程序设计：

毫微程序设计采用两级微程序的设计方法。
第一级微程序为垂直型微指令，并行功能不强，但有严格的顺序结构，由它确定后续微指令的地址，当需要时可调用第二级。
第二级微程序为水平型微指令，具有很强的并行操作能力，但不包含后续微指令的地址。第二级微程序执行完毕后又返回到第一级微程序。

毫微程序设计的基本概念
微程序设计用微程序解释机器指令，毫微程序设计用毫微程序解释微指令

微程序控制：

串行微程序控制：取第i条微指令——》执行第i条微指令——》取第i计1条微指令——》执行第+1条微指令
并行微程序控制：和流水线一样，执行i条微指令同时取i+1条微指令