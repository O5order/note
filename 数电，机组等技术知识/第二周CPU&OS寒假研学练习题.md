# 第二周CPU&OS寒假研学练习题

公式显示出现问题，请打开LaTeX公式规则。

[TOC]



## 第六章

1.最少用几位二进制数即可表示任一五位长的十进制正整数?

==五位长十进制数最大是99999，2^17^=131072,所以是17位==

2.设机器数字长为8位(含1位符号位在内)，写出对应下列各真值的原码、补码和反码。

​	$-13/64, 29/128, 100, -87$ 

-13/64:  0.203125原码：1.001101，反码：1.110010，补码：1.110011

29/128, 原码：0.0011101反码：0.0011101补码：0.0011101

100, 原码：0，1100100，反码：0，1100100补码：0，1100100

-87，原码：1，1010111反码：1，0101000补码：1，0101001

3.已知$[x]_补$，求$[x]_原$和$x$。

==$[x]_原$=$[x]_补$-1再取反，x是原码转为二进制的结果，==

4.设机器数字长为8位(含1位符号位在内)，分整数和小数两种情况讨论真值x为何值时，$[x]_补 =[x]_原$成立。

==正数时==

==x为小数时，若x<0,当x= -1/2时，$[x]_补 =[x]_原$=1.100 0000==

==当x为整数时,x=0时,若x<0,当x= -64时，$[x]_补 =[x]_原$=1,100 0000,==

5.设$x$为真值，$x^*$为绝对值，说明$[-x^*]_补 = [-x]_补$能否成立。

==由于**<u>求一个数的相反数的补码只需要将原数连同符号位在内，每位取反，末位加1即可（无论原数正负）</u>**，因此x正数就成立==

6.讨论$[x]_补>[y]_补$，是否有$x>y$？

==都是正数时，补码大的原数一定小，所以都是正数不存在，同理都是负数补码大原数大，所以都是负数满足，一正一负就只能是y<0,x>0成立==

7.当十六进制数9B和FF分别表示为原码、补码、反码、移码和无符号数时，所对应的十进制数各为多少（设机器数采用一位符号位）？

9B：

|  真值  | 无符号数  |    原码    |    反码    |    补码    |    移码    |
| :----: | :-------: | :--------: | :--------: | :--------: | :--------: |
| 二进制 | 1001 1011 | 1,001 1011 | 1,110 0100 | 1,110 0101 | 0,001 1011 |
| 十进制 |    155    |    -27     |    -100    |    -101    |     27     |

FF：

|  真值  | 无符号数  |    原码    |    反码    |    补码    |    移码    |
| :----: | :-------: | :--------: | :--------: | :--------: | :--------: |
| 二进制 | 1111 1111 | 1,111 1111 | 1,000 0000 | 1,000 0001 | 0,111 1111 |
| 十进制 |    255    |    -127    |     -0     |     -1     |    127     |

8.在整数定点机中，设机器数采用一位符号位，写出$\pm0$的原码、补码、反码和移码，得出什么结论？

==+0原码：0.00……0，反码：0.00……0，补码：0.00……0，移码：1.00……0==

==-0原码：1.00……0，反码：1.11……1，补码：0.00……0，移码：1.00……0==

==0补码、移码的表示唯一，原码、反码不唯一。==

9.设浮点数格式为：阶码5位（含1位阶符），尾数11位（含1位数符）。写出51/128、-27/1024、7.375、-86.5所对应的机器数。要求如下：
	（1）阶码和尾数均为原码；
	（2）阶码和尾数均为补码；
	（3）阶码为移码，尾数为补码。

x~1~ =51/128=0.011 0011=2^-1^×0.110011

x~2~=−27/1027=−0.00 0001 1011=2^−5^×−0.11011

x~3~=7.375=111.011 =2^3^×0.111011

x~4~=−86.5=−1010 110.1=2^7^×−0.10101101

（1）

[*x*1]浮=1,0001；0.11 00110000

[*x*2]浮=1,0101；1.1101100000

[*x*3]浮=0,0011；0.1110110000

[*x*4]浮=0,0111；1.1010110100

（2）

[x1]浮=1,1111；0.1100110000

[x2]浮=1,1011；1.0010100000

[*x*3]浮=0,0011；0.11 1011 0000

[*x*4]浮=0,0111；1.01 0100 1100

（3）

[x1]浮=0,1111；0.1100110000

[x2]浮=0,1011；1.0010100000

[x3]浮=1,0011；0.1110110000

[*x*4]浮=1,0111；1.01 0100 1100

10.设机器数字长为16位，写出下列各种情况下它能表示的数的范围。设机器数采用一位符号位，答案均用十进制表示。
	(1)无符号数;   ==65535==
	(2)原码表示的定点小数;   ==−(1−2^−15^)∽1−2^−15^==
	(3)补码表示的定点小数;   ==−1∽1−2^−15^==
	(4)补码表示的定点整数; ==−2^15^∽2^15^−1==
	(5)原码表示的定点整数;  ==−(2^15^−1)∽2^15^−1==
	(6)浮点数的格式为:阶码6位(含1位阶符)，尾数10位(含1位数符)。分别写出正数和负数的表示范围;
	**(注:加条件:阶原尾原非规格化数。)**

==2^31^×(1−2^−9^)∽2^−32^×2^−9^==

==2^−32^×(−2^−9^)∽−2^31^×(1−2^−9^)==

​	(7)浮点数格式同(6)，机器数采用补码规格化形式，分别写出其对应的正数和负数的真值范围。

==2^31^×(1−2^-9^)∽2^−32^×2^−1^==

==−2^−32^×(2^−1^+2^−9^)∽2^31^×(−1)==

11.设机器数字长为8位(含1位符号位)，对下列各机器数进行算术左移一位、两位，算术右移一位、两位，讨论结果是否正确。
	$[x1]_原=0.001\ 1010;[y1]_补=0.101\ 0100;[z1]_反=1.010\ 1111;$
	$[x2]_原=1.110\ 1000;[y2]_补=1.110\ 1000;[z2]_反=1.110\ 1000;$
	$[x3]_原=1.001\ 1001;[y3]_补=1.001\ 1001;[z3]_反=1.001\ 1001。$

==加粗的出错==

1.0.0110100  0.1101000 0.0001101 0.0000110     **0.0101000** 0.1010000  0.0101010 0.0010101      0.1011110 **0.0111100** 0.1010111  0.0101011

2.1.1010000 1.0100000 **1.1110100 1.0111010**      1.1010000 1.0100000 1.1110100 1.1111010       1.1010001   1.0100011 1.1110100 1.1111010

3.**1.0110010 1.1100100 1.1001100 1.0100110**        **1.0110010 1.1100100** 1.1001100 1.1100110        **1.0110011 1.1100111**  1.1001100 1.1100110

12.试比较逻辑移位和算术移位。

==算术移位主要用来进行有符号数的倍增、减半；逻辑移位主要用来进行无符号数的倍增、减半。==

==算术左移同逻辑左移方法一样，都是最低位补0；算术右移最高位补的数和符号位的数一致；逻辑右移最高位补的数为0。==

13.用原码一位乘、两位乘和补码一位乘(Booth算法)、两位乘计算x·y。
	(1)x=0.110 111，y=-0.101 110;

符号位为1，数值位：第一位为0，加0，第二位为1，为0.1101110，右移一位再加0.110111，结果为1.01001010，右移一位变成0.101001010加数为1.100000010，右移一位加零变成0.1100000010，再右移一位0.01100000010加数为1.00111100010右移一位为0.100111100010

过于麻烦，以下用笔写：

![IMG_20240204_105125_edit_1048862765553795](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/IMG_20240204_105125_edit_1048862765553795.jpg)

![IMG_20240204_105131_edit_1048847550612238](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/IMG_20240204_105131_edit_1048847550612238.jpg)



(2)x=-0.010 111，y=-0.010 101:
	(3)x=19， y= 35;
	(4)x= 0.110 11， y= -0.111 01。



14.对于尾数为40位的浮点数(不包括符号位在内)，若采用不同的机器数表示，试问当尾数左规或右规时，最多移位次数各为多少?

==对于尾数为40位的浮点数，若采用原码表示，当尾数左规时，最多移位39次；反码表示时情况一样;若采用补码表示，当尾数左规时，正数最多移位39次同原码;负数最多移位40次。==

==右规最多只需要一次，因为即使是最大的两个尾数相加(1.11…1+1.11…1)，其结果也不会达到4，故尾数的整数部分最多有2位，保留一个隐含的"1"后，最多只有一位被右移到小数部分==

15.按机器补码浮点运算步骤计算$[x\pm y]_补$
	$(1)x=2^{-011}\times 0.101\ 100， y=2^{-010}\times (-0.011\  100);\\ (2) x=2^{-011}\times (-0.100\ 010),y=2^{-010}\times (-0.011\  111);\\ (3)x=2^{101}\times (-0.100\ 101)，y=2^{100}\times (-0.001\ 111)。$           

![IMG_20240203_105500_edit_1000558677406336](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/IMG_20240203_105500_edit_1000558677406336.jpg)

16.设机器字长为32位，用与非门和与或非门设计一个并行加法器(假设与非门的延迟时间为30ns，与或非门的延迟时间为45ns)，要求完成32位加法时间不得超过0.6$\mu s$。画出进位链及加法器逻辑框图。

串行进位链：T=2×32×30=1920ns>0.6×1000=600ns

单重分组跳跃进位：分4个1组，T=2.5×8×30=600ns，考虑到其他因素因此6个以上一组符合情况。

双重分组跳跃进位：44分，4个一小组，4个小组一大组。T=2.5×30×4=300ns

![qq_pic_merged_1706931020715](https://o5orde-oss.oss-cn-beijing.aliyuncs.com/qq_pic_merged_1706931020715.jpg)

## 第七章

1.什么叫机器指令？什么叫指令系统？为什么说指令系统与机器的主要功能以及硬件结构之间存在着密切的关系？

==机器指令：每一条机器语言，CPU可以执行的语句。==

==指令系统：全部机器指令的集合。==

==因为指令系统是计算机硬件和软件的接口部分，是全部机器指令的集合。==

2.什么叫寻址方式？为什么要学习寻址方式?

==寻址方式：指确定本条指令的数据地址以及下一条将要执行的指令地址的方法==

==与硬件结构相关，因此直接影响指令格式和指令功能。学习寻址方式是为了找到指令中参与操作的数据，然后根据指令，得出结果==

3.什么是指令字长、机器字长和存储字长？

==指令字长：是指机器中二进制代码的总位数。由操作码的长度，操作数地址的长度，操作数地址的个数决定，不同指令的字长不同。==

==机器字长：计算机（CPU）进行一次整数运算所能处理的二进制数据的位数（整数运算即定点整数运算）。也就是运算器进行定点数运算的字长，通常也是CPU内部数据通路的宽度。即字长越长，数的表示范围也越大，精度也越高，机器字长也会影响机器的运算速度。==

==存储字长：一个存储单元存储一串二进制代码（存储字），这串二进制代码的位数称为存储字长，存储字长可以为8位、16位、32位等。==

4.某指令系统字长为16位，地址码取4位，试提出一种方案，使指令系统有8条三地址指令、16条二地址指令、100条一地址指令。

三地址：0000~0111

二地址：10000000~10001111

一地址：100100000000~100101100011

5.试比较间接寻址和寄存器间接寻址。

==间接寻址和寄存器间接寻址都可扩大寻址范围，他们都要形成有效地址：间接寻址通过访存（若是多次间址还需多次访存）从而得到有效地址；寄存器间接寻址有效地址不是存放在存储单元中，而是存放于寄存器中，因此比间接寻址少访存一次。==

6.某机主存容量为$4\ M\times 16$位,且存储字长等于指令字长，若该机指令系统可完成108种操作,操作码位数固定，且具有直接、间接、变址、基址、相对、立即等六种寻址方式，试回答以下问题。
	（1）画出一地址指令格式并指出各字段的作用。

108种因此操作码为2^7^才能符合要求OP为7，6种寻址方式，M为3，16-7-3=6（A）

| OP （7位）操作码字段 | M （3位）寻址方式字段 | A （6位）地址码字段 |
| :------------------: | :-------------------: | :-----------------: |

​	（2） 该指令直接寻址的最大范围。

2^6^=64

​	（3）一次间接寻址和多次间接寻址的寻址范围。

存储字长为16位，一次间址的寻址范围为 2^16^；若多次间址，需用存储字的最高位来区别是否继续间接寻址，故寻址范围为 2^15^ 。

​	（4）立即数的范围（十进制表示）。

 有符号数:-32~31,无符号数: 0~63

​	（5） 相对寻址的位移量(十进制表示)。

-32~31

​	（6）上述六种寻址方式的指令中哪一种执行时间最短,哪一种最长，为什么？哪一种便于程序浮动，哪一种最适合处理数组问题？

立即数由指令直接给出，故立即寻址的指令执行时间最短。

间接寻址在指令的执行阶段要多次访存 ( 一次间接寻址要两次访存，多次间接寻址要多次访存 ) ，执行时间最长。

变址寻址由于变址寄存器的内容由用户给定，而且在程序的执行过程中允许用户修改，而其形式地址始终不变，故变址寻址的指令便于用户编制处理数组问题的程序。

相对寻址操作数的有效地址只与当前指令地址相差一定的位移量，指令随程序在存储空间的位置不同而不同，但是每条指令之间的相对位移量不变，因此更有利于程序浮动。

​	（7）如何修改指令格式，使指令的寻址范围可扩大到4M？

要扩大到4M需要22位有效地址，用一些硬件资源代替指令字中的地址码字段如使用十六位寄存器，在完成寻址操作后由硬件自动完成寻址。

​	（8）为使一条转移指令能转移到主存的任一位置，可采取什么措施？简要说明之。

为使一条转移指令能转移到主存的任一位置，因此寻址范围须达到 4M ，可由（7）的操作实现

7.CPU 内有 32 个 32 位的通用寄存器，设计一种能容纳 64 种操作的指令系统。假设指令字长等于机器字长，试回答以下问题。

8.什么是RISC? 简述它的主要特点。

精简指令集计算机，

- 选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合

- 指令长度固定、指令格式种类少、寻址方式少

- 只有LOAD / STORE 指令访存

- CPU中有多个通用寄存器

- 采用流水技术  一个时钟周期内完成一条指令

- 采用组合逻辑实现控制器

9.比较 RISC 和 CISC 的异同之处。

比较：1.RISC更能充分利用VLSI芯片的面积

2.RISC更能提高计算机运算速度，指令数、指令格式、寻址方式少，通用寄存器多，采用组合逻辑，便于实现指令流水
3.RISC便于设计，可降低成本，提高可靠性

4.RISC不易实现指令系统兼容



10.RISC 机中指令简单,有些常用的指令未被选用,它用什么方式来实现这些常用指令的功能.试举例说明。

通过选取使用频率较高的而且功能简单、能在一个节拍内执行完成的指令，使用这些指令组成一段子程序从而实现较复杂的功能加法指令还可以替代清楚寄存器指令，比如置数指令可以由加法指令完成( R~1~) + 0 → R~4~替代了0→R~4~ 

## 第八章

1.什么是指令周期？指令周期是否有一个固定值？为什么？

==指令周期：指取并执行一条指令所需时间。==

==计算机中各种指令执行所需的时间差异很大，因此为了提高CPU运行效率，即使在同步控制的机器中，不同指令的指令周期长度都是不一致的，也就是说指令周期对于不同的指令来说不是一个固定值。==

2.中断周期前是什么阶段？中断周期后又是什么阶段？在中断周期CPU应完成什么操作？

==中断周期前为执行周期，中断周期后为取指周期。
中断周期 CPU 完成下列操作：CPU 访存操作；保存程序断点；硬件关中断；将向量地址送程序计数器（硬件向量法）或将中断识别程序入口地址送往程序计数器（软件查询法）。==

3.存储器中有若干数据类型:指令代码、运算数据、堆栈数据、字符代码和BCD码,计算机如何识别这些代码？

==取指阶段从存储器取出的信息为指令代码。
执行阶段从存储器取出的可以是运算数据、字符代码或BCD码，具体是哪一种信息与指令的操作码有关。
凡是根据堆栈指示器SP所指示的地址访存时所获得的数据即为堆栈数据。==

4.什么叫系统的并行性?粗粒度并行和细粒度并行有何区别？

==并行包含同时性和并发性两个方面。前者是指两个或多个事件在同一时刻发生，后者是指两个或多个事件在同一时段发生。也就是说，在同一时刻或同一时段内完成两种或两种以上性质相同或不同的功能，只要在时间上相互重叠，就存在并行性。==
==并行性分粗粒度并行和细粒度并行两类。==
==粗粒度并行性是在多个处理机上分别运行多个进程，由多台处理机合作完成一个程序，一般用算法（软件）实现。==
==细粒度并行性是指在处理机的操作级和指令级的并行性，一般用硬件实现，其中指令流水就是一项重要技术。==

5.什么是指令流水？画出指令二级流水和四级流水的示意图，它们中哪一个更能提高处理器速度，为什么？

==指令流水就是改变各条指令按顺序串行执行的规则，使机器在执行上一条指令的同时，取出下一条指令，把指令周期划分得更细，使更多的指令在同一时间内执行，更能提高处理器速度，故四级流水比二级流水的处理速度高。==

6.当遇到什么情况时流水线将受阻？举例说明。

==1.结构相关==

==不同指令争用同一功能部件产生资源冲突==

==2.数据相关==

==不同指令因重叠操作，可能改变操作数的读/写访问顺序（然而实际上这些指令改变顺序就会出错）==

==3.控制相关==

==由转移指令引起==

==比如条件转移指令，在未执行前，不知道是否满足条件进行跳转，导致其他流水线正常顺序进行，可是发生跳转后，其他流水线工作因此全部作废。造成损失。==

7.为什么说超长指令字比超标量更能提高并行处理能力？

==超标量的指令来自同一标准的指令流，超长指令字由编译程序在编译时挖掘出指令间潜在的并行性后，把多条能并行操作的指令组合成一条具有多个操作码字段的超长指令，由这条超长指令控制超长指令字机中多个独立工作的功能部件，由每个操作码字段控制一个功能部件，相当于同时执行多条指令，所以超长指令字技术比超标另具有更高的并行处理能力。==

8.什么是中断?设计中断系统需考虑哪些主要问题？

==CPU在程序运行过程中，遇到异常情况或特殊请求，需暂停现行程序，转至对这些异常情况或特殊请求的处理，处理完后再返回到原程序断点处继续执行，这一过程即为中断。==

(1)各中断源如何向CPU提出请求?
(2)各中断源同时提出请求怎么办?
(3) CPU什么条件、什么时间、以什么方式响应中断?
(4)如何保护现场
(5)如何寻找入口地址？
(6)如何恢复现场
(7)处理中断的过程中又出现新的中断怎么办?

9.中断系统中采用屏蔽技术有何作用？

==（1）在多重中断系统中，CPU响应中断后不希望有级别低的其他中断请求的干扰，采用屏蔽技术可屏蔽本级和更低级的中断请求，使中断处理可靠进行。==
==（2）改变中断处理的优先级。==
==（3）有选择地封锁部分中断请求，使程序控制更灵活。==

10.在中断处理过程中，为什么要进行中断判优？有几种实现方法？若想改变原定的优先顺序，可采取什么措施？

==因为任何一个中断系统在任一时刻，只能响应一个中断请求。但许多中断源提出请求都是随机的，当某一时刻有多个中断源提出中断请求时，中断系统必须按其优先顺序予以响应，因此要进行中断判优。==
==中断判优有两种方法实现：硬件排队和软件排队。前者用组合逻辑电路实现，后者用程序按优先级别（从高到低）顺序查询各中断源，以实现排队。
欲想改变优先顺序，可采用屏蔽技术，重新设置屏蔽字。==

## 第九章

1.设CPU内有这些部件:PC、IR、MAR、MDR、AC、CU。
	(1)写出取指周期的全部微操作。

PC→MAR     现行指令地址→MAR
Ⅰ →R      命令存储器读
M(MAR)→MDR       现行指令从存储器中读至MDR
MDR→IR         现行指令→IR
OP(IR)→CU        指令的操作码→CU
(PC)＋1→PC        形成下一条指令的地址

​	(2)写出减法指令“SUB X”、取数指令“LDA X”、存数指令“STA X”(X均为主存地址)在执行阶段所需全部微操作。

Ad(IR)→MAR      指令的地址码字段→MAR
Ⅰ→R        命令存储器读
M(MAR)→MDR       操作数从存储器中读至MDR
(ACC)- (MDR)→ACC         两数相减结果送ACC



Ad(IR)→MAR        指令的地址码字段→MAR
l →R        命令存储器读
M(MAR)→MDR        操作数从存储器中读至MDR
MDR →ACC              操作数



Ad(IR)→MAR       指令的地址码字段→MAR
Ⅰ →w        命令存储器写
ACC-MDR       欲写入的数据→MDR
MDR→M (MAR)         数据写至存储其中

​	(3)当上述指令为间接寻址时,写出执行这些指令所需的全部微操作。

间址周期微操作：

Ad(IR)→MAR        指令的地址码字段→MAR
Ⅰ→R        命令存储器读
M(MAR)→MDR         数据写至存储器中

进入执行周期，这三条指令的第一个微操作均为MDR → MAR( 有效地址送 MAR ) 其余微操作不变。

​	(4)写出无件转移指令“JMP Y”和结果溢出则转指令“BAO Y”执行阶段所需的全部微操作。

Ad(IR) →PC         转移(目标)地址Y→PC

Z·Ad(IR)→PC当Z=1时，转移(目标)地址Y →PC(Z为标记触发器，结果为0时Z=1）

2.什么是指令周期、机器周期和时钟周期？三者有何关系？

==指令周期是CPU取出并执行一条指令所需的全部时间，即完成一条指令的时间。
机器周期是所有指令执行过程中的一个基准时间，通常以存取周期作为机器周期。
时钟周期是机器主频的倒数也可称为节拍，它是控制计算机操作的最小单位时间。
一个指令周期包含若干个机器周期，一个机器周期又包含若干个时钟周期，每个指令周期内的机器周期数可以不等，每个机器周期内的时钟周期数也可以不等。==

3.试比较同步控制、异步控制和联合控制的区别。

==同步控制，任何一条指令或指令中任何一个微操作的执行都是事先确定的，并且都是受统一基准时标的时序信号所控制的方式，每一个操作出现的时间与基准时标保持一致。==

==异步控制不存在基准时标信号，没有固定的周期节拍和严格的时钟同步，执行每条指令和每个操作需要多少时间就占用多少时间。这种方式微操作的时序由专门的应答线路控制，即当 控制单元CU 发出执行某一微操作的控制信号后，等待执行部件完成了该操作后发回“回答”（或“结束”）信号，再开始新的微操作，使 CPU 没有空闲状态，但因需要采用各种应答电路，故其结构比同步控制方式复杂。==

==同步控制和异步控制相结合就是联合控制方式。这种方式对各种不同指令的微操作实行大部分统一、小部分区别对待的办法。例如，对每条指令都有的取指令操作、CPU内部各操作，采用同步方式控制；对那些时间难以确定的微操作，如I/O操作，则采用异步控制，以执行部件送回的“回答”信号作为本次微操作的结束。==

4.设某计算机的CPU主频为8MHz,每个机器周期平均含2个时钟周期,每条指令平均有4个机器周期，试问该计算机的平均指令执行速度为多少MIPS。若CPU主频不变，但每个机器周期平均含4个时钟周期，每条指令平均有4个机器周期,则该机的平均指令执行速度又是多少MIPS?由此可得出什么结论?

因为主频为8MHz，所以时钟周期为0.125μs，机器周期为 0.125×2=0.25μs，指令周期为 0.25×4=1μs平均指令执行速度为1MIPS
如果做出更改就会变成0.5MIPS

结论:机器速度不仅与主频有关，还与机器周期中所含的时钟周期以及指令周期中所含的机器周期数有关。同样主频的机器，由于机器周期所含的时钟周期数不同，机器的速度也不同。机器周期中所含时钟周期数少的机器，速度更快。

## 第十章

1.假设响应中断时,要求将程序[断点](https://so.csdn.net/so/search?q=断点&spm=1001.2101.3001.7020)存在堆栈内,并且采用软件方法寻找中断服务程序的入口地址，试写出中断隐指令的微操作及节拍安排。

T0      0 →EINT，SP →MAR
T1      PC→MDR,0 →-W ,SP＋1→SP
T2       MDR→M(MAR)
T3       SP →MAR
T4       PSW →MDR,0 →-W ,SP＋1 →SP
T5       0 →PC,MDR→M (MAR)

2.写出完成下列指令的微操作及节拍安排(包括取指操作)。

3.假设CPU在中断周期用堆栈保存程序断点，而且进生栈时指针减1(具体操作是先修改栈指针后存数),出栈时指针加1。分别写出组合逻辑控制和微程序控制在完成中断返回指令时,取指阶段和执行阶段所需的全部微操作命令及节拍安排。

(1)组合逻辑控制:

取指阶段
T0       PC→MAR，1→R
T1       (PC)＋1→PC,M(MAR)→MDR
T2       MDR→IR，OP(IR)→ID
执行阶段:
T0       SP → MAR,1 → Y
T1       AM(MAR)→MDR
T2       MDR→ PC, (SP)＋1 →SP

(2）微操作命令:

取指阶段
T0    PC→MAR,1 →R
T1    Ad(CMDR)→CMAR
T2     M(MAR)→MDR，(PC)＋1→PC
T3     Ad(CMDR)→CMAR
T4      MDR→IR
T5      OP(IR)→微地址形成部件→CMAR

执行阶段
T0      SP →MAR,1 →R
T1      Ad(CMDR)→CMAR
T2      M(MAR)→MDR
T3      Ad(CMDR)→CMAR
T4      MDR →PC，(SP）＋1→SP
T5       Ad(CMDR)→CMAR

4.试比较组合逻辑设计和微程序设计的设计步骤和硬件组成，说明哪一种控制速度更快,为什么？

==组合逻辑控制器的设计思想是采用硬连线逻辑。首先根据指令系统，写出对应所有机器指令的全部微操作及其节拍安排，然后列出操作时间表，再写出每一种微操作的逻辑表达式，化简后画出相应的逻辑图，即完成了设计。这种逻辑电路主要由门电路构成的复杂树形网络，一旦构成后，除非在物理上进行重新连线，否则要增加新的控制功能是不可能的。
微程序控制器的设计思想是采用存储逻辑。首先根据指令系统，写出对应所有机器指令的全部微操作及其节拍安排，然后列出操作时间表，再根据微操作的数目，经压缩确定微指令的控制方式、下地址形成方式、微指令格式及微指令字长，编写出全部微指令的代码，即完成了设计。最后将微指令的代码注入到 ROM 中，即可作为微操作的命令信号。
组合逻辑控制速度更快，因为它的程序执行基本上是由硬件完成的。==

5.微指令的操作控制有几种编码方式？各有何特点？哪一种控制速度最快？

三种
==（1）直接控制，又称直接编码，其特点是操作控制字段中的每一位代表一个微命令，其优点是简单直观，输出直接用于控制，执行速度快。缺点是微指令字长较长，使控存容量较大。
（2）字段直接编码控制，其特点是将微指令操作控制字段分成几段，并使每个字段经译码后发出各个微操作命令，每个字段中的微命令必须是互斥的。这种控制方式用较少的二进制信息表示较多的微命令信号，它缩短了微指令字长，但增加了译码电路，使微程序的执行速度降低。这种编码控制又叫显式控制。
（3）字段间接编码控制，这种方式一个字段的某些命令还需由另一个字段中的某些命令解释，才能使微指令有确切含义，故又称为隐式编码，这种方法更能缩短微指令字长。
此外还可以把直接控制和字段编码控制混合使用。三种控制方式中，直接控制速度最快。==

6.什么是垂直型微指令？什么是水平型微指令？各有何特点？

==垂直型微指令是指一次只能执行一个微命令的微指令;
水平型微指令是指一次能定义并能并行执行多个微命令的微指令。==

==对比：==

==(1)水平型微指令比垂直型微指令并行**<u>操作能力强，灵活性强</u>**
(2)水平型微指令执行一条机器指令所要的微指令**<u>数目少，速度快</u>**
(3)水平型微指令**<u>用较短的微程序结构换取较长微指令结构</u>**
(4)水平型微指令与机器指令**<u>差别大</u>**==

7.能否说水平型微指令就是直接编码的微指令，为什么？

==不能，因为符合水平型微指令特征的微指令都属于水平型微指令，常见的有：直接编码、字段直接编码、字段间接编码，及混合编码等。直接编码的微指令只是最典型的一种。==

8.微指令操作控制字段采用直接编码或显式编码时，其微指令字长如何确定？

==在微指令的操作控制字段中，每一位代表一个微操作命令，这种编码方式即为直接编码方式。直接编码方式含义清晰，只要微指令从控存读出，即刻可由控制字段发出命令，速度快。但由于机器中微操作命令甚多，可能使微指令操作控制字段达几百位，造成控存容量极大。
采用显式编码可用较少的二进制信息表示较多的微操作命令信号。例如，3位二进制代码译码后可表示7个互斥的微命令，留出一种状态表示不发微命令，与直接编码用7位表示7个微命令相比，减少了4位，缩短了微指令的长度。至于操作控制字段应分几段，与需要并行发出的微命令个数有关，若需并行发出8个微命令，就可分8段。每段的长度可以不等，与具体要求互斥的微命令个数有关，若某类操作要求互斥的微命令仅有6个，则字段只需安排3位即可。==

9.试比较静态微程序设计和动态微程序设计。

==静态﹒微程序无须改变，采用 ROM
动态    通过改变微指令和微程序改变机器指令，有利于仿真，采用EPROM==

10.解释机器指令、微指令、微程序、毫微指令和毫微程序以及它们之间的对应关系。

==机器指令由“0”、“1”代码组成，能被机器直接识别。
机器指令可由有序微指令组成的微程序来解释，微指令也是由“0”、“1”代码组成，也能被机器直接识别，是用来解释机器指令的。==

==毫微指令是用来解释微指令的。==

==微程序可以看做是解释机器指令的==

==毫微程序可以看做是解释微程序的==。

11.毫微程序设计的特点是什么?与微程序设计相比,其硬件组成有何不同?

==微程序设计用微程序解释机器指令，毫微程序设计用毫微程序解释微指令==

==采用毫微程序设计计算机需要两级控制存储器，二级控制存储器虽然能减少控制存储器的容量，但因有时一条微指令要访问两次控制存储器，影响了速度。==